#!/bin/env python2
#Module 	:: Gaussian_Manage
#Authors	:: Ying Zhang and Xin Xu 
#Purpose	:: 1) Analysis the input file of Gaussian package;
#       	:: 2) Generate the input file of Gaussian package;
#       	:: 3) Collect results from Gaussian package;
#       	:: 4) Generate rGO interface file;
#           :: 5) Interface with R5DFT and DFTD
#           :: All in all, a well-defined private interface with Gaussian series
#              package
#History    :: 1.0(20090825) Completes basic functions for Gaussian IO.
#                            There are about three classes:
#                                1) GauIO       : obtain all information from gaussian input
#                                2) ChkHandle   : collect results from chk of gaussian
#                                3) LogHandle   : collect results from log of gaussian
#              1.1(20090910) Add one more class "OptHandel" for rGO interface.
#              1.2(20090925) 1) Make GauIO class to unopen gaussian input as default.
#                            2) Build new class of "R5DFT" to handle R5DFT calculation 
#                               cooperating with Gaussian packages.
#              1.3(20091021) Build new class of "DFTD" to handle DFT+D calculation, in which
#                            dispertion term is obtained from the private module "dft_d" and
#                            conventional DFT term is generated by Gaussian packages.
#              1.4(20091104) Add one more function "collect_Geom_converged()" into the class of
#                            "LogHandle"
#              1.5(20091209) 1) Add more indexes of atoms into "GauIO.AtDict"
#                            2) Fix a bug to make "GauIO.run_GauJob" can handle more than 2 jobs
#                               in one DIR correctly
#                            3) Modify "R5DFT.__init__" to handle "gen" basis set collectly
#              1.6(20100426) 1) Fix a bug in "GauIO.get_TCSGR" associated with filtering "RestList"
#                               for external gen basis file statement
#                            2) Fix a bug in "GauIO.get_TCSGR" about conflicting between "RestList"
#                               and l608 calculation statement for DFT part of R5DFT
#                            3) Fix a bug in "R5DFT.__init__" to handle nonstandard "gen" basis set
#                               file
#                            4) Fix a bug in "GauIO.collect_Geom" to read "IAn" from "fchk" file
#                            5) Add "GauIO.AnDict" to index atom name by IAn; Modify "GauIO.collect
#                               _Geom" to construct "GauIO.GeomList" using atom name indexed by 
#                               AnDict
#                            6) Fix bug in "GauIO.TCSGR" to read atom-frozen and Oniom-type
#                               Cartesian input correctly
#                            7) Add "XYG3_FC" into R5DFT for frozen core XYG3 calculation
#                            8) Handle the chkfile direction by "ChkReplace.py" and 
#                               "G03_Envirenment.csh" in "GauIO.run_GauJob"
#                               a) "gaussian_manage.py->GauIO.run_GauJob()"
#                               b) "G03_Environment"
#                               c) "Utility/ChkReplace.py"
#                            9) Fit bug for "fchk=all" calculation: the changed code:
#                               a) "GauIO.MoreOptionDict['fchk=all']"
#                               b) "GauIO.run_GauJob()"
#                            10) Fit bug for returning unrequired chkfile: the changed code:
#                               a) "GauIO.MoreOptionDict['%chk']"
#                               b) "GauIO.MachAndOpt()": generate GauIO.MoreOptionDict['%chk']
#                               b) "GauIO.run_GauJob()": copy chkfile or not depends on '%chk'
#                            11) Sync log-file for R5DFT by threads: the changed codes:
#                               a) "GauIO.run_GauJob()": add the argument "sync" to return CurrDir 
#                               b) "R5DFT.run_Job()": sync log from CurrDir by threads
#                               c) "R5DFT.cut_log()": append log information correctly
#                               d) "R5DFT.filter_log()": filter log information for printing
#              2.0(20100617) 1) Reach private modules from the grobal environment of 
#                               "IGOR_MODULES_PATH"
#                            2) Add four arguments into DFTD class for dispersion parameters
#                               optimization
#                            3) Temp setting about formchking chk-file for G09 being unable to 
#                               handel "extraoverlay" correctly. "ChkHandle.__init__()"
__version__ = "2.0(20100617)"

class GauIO:
    '''\
 Manage the input file of the Gaussian package.\n\
   INPUT VARIABLES    ::\n\
 iout                : FLOW of output file\n\
 fn                  : STRING of the input file name\n\
                       fn = None -> default, bypass the action to open the file\n\
 bugctrl             : INTEGER to control the bebug information print\n\
                       0: default\n\
                       1: more results \n\
                       2: more results add detail debugging info.\n\
    MANAGE VARIABLES   :: \n\
       (***Note***: if need, all the strings following have to be specified in lower style\n\
 self.IOut           : FLOW of output file\n\
 self.FileName       : STRING of the input file name\n\
 self.ModuDir        : STRING of the path name to reach the gaussian environment
 self.JobName        : STRING of this job name\n\
 self.ChkName        : STRING, the name of the check file\n\
 self.CartesianFlag  : LOGICAL to state geomerty input is Cartesian coordinate or not\n\
 self.IPrint         : INTEGER of print level\n\
 self.Charge         : INTEGER of input Chage   \n\
 self.Spin           : INTEGER of input Spin    \n\
 self.NAtom          : INTEGER of atoms number \n\
 self.MachineList    : LIST of machine commands\n\
 self.OptionList     : LIST of options\n\
 self.TitleList      : LIST of this job title \n\
 self.GeomList       : LIST of input geometry   \n\
 self.IAn            : LIST of Atom index\n\
 self.AtLabel        : LIST of Atom label\n\
 self.CList          : LIST of geometry coordinate\n\
 self.ZList          : LIST of geometry Z-matrix\n\
 self.ZListR         : LIST of Z-matrix parameters\n\
 self.RestList       : LIST of rest content after geometry\n\
 --------------------------Results Collected--------------------------------------\n\
 self.EngyReal       : FLOAT, the total energy of the quesion\n\
 self.ForcList       : LIST, Force of the quesion\n\
 self.HessList       : LIST, Hessian of the quesion\n\
 self.DipoList       : List, Dipole\n\
 self.DpDvList       : List, Dipole derivatives\n\
 self.PolaList       : List, Polarizability\n\
 --------------------------Several varibles for options control--------------------------\n\
 self.KickOptionList : DICTIONARY of initial disable options\n\
              dict.keys() = []\n\
 self.MoreOptionDict : DICTIONARY of options which need more detailed handle\n\
              dict.keys() = ['checkpoint','allcheck','extraoverlay','fchk=all','%chk']\n\
 self.ExOvList       : LIST of IOPs for the option "extraoverlay"\n\
 ----------------------------------------------------------------------------------------\
 '''

    AtDict	= {\
   'x':0  ,
   'h':1  , 'he':2  ,\
  'li':3  , 'be':4  ,  'b':5  ,  'c':6  ,  'n':7  ,  'o':8  ,  'f':9  , 'ne':10 ,\
  'na':11 , 'mg':12 , 'al':13 , 'si':14 ,  'p':15 ,  's':16 , 'cl':17 , 'ar':18 ,\
   'k':19 , 'ca':20 , 'ga':31 , 'ge':32 , 'as':33 , 'se':34 , 'br':35 , 'kr':36 ,\
  'sc':21 , 'ti':22 ,  'v':23 , 'cr':24 , 'mn':25 ,\
  'fe':26 , 'co':27 , 'ni':28 , 'cu':29 , 'zn':30 ,\
  'rb':37 , 'sr':38 , 'in':49 , 'sn':50 , 'sb':51 , 'te':52 ,  'i':53 , 'xe':54 ,\
   'y':39 , 'zr':40 , 'nb':41 , 'mo':42 , 'tc':43 ,\
  'ru':44 , 'rh':45 , 'pd':46 , 'ag':47 , 'cd':48 \
                  }
    AnDict	= {\
     0:'X' ,
     1:'H' ,   2:'He',\
     3:'Li',   4:'Be',   5:'B' ,   6:'C' ,  7 :'N' ,   8:'O' ,   9:'F' ,   10:'Ne',\
    11:'Na',  12:'Mg',  13:'Al',  14:'Si',  15:'P' ,  16:'S' ,  17:'Cl',   18:'Ar',\
    19:'K' ,  20:'Ca',  31:'Ga',  32:'Ge',  33:'As',  34:'Se',  35:'Br',   36:'Kr',\
    21:'Sc',  22:'Ti',  23:'V' ,  24:'Cr',  25:'Mn',\
    26:'Fe',  27:'Co',  28:'Ni',  29:'Cu',  30:'Zn',\
    37:'Rb',  38:'Sr',  49:'In',  50:'Sn',  51:'Sb',  52:'Te',  53:'I',    54:'Xe',\
    39:'Y' ,  40:'Zr',  41:'Nb',  42:'Mo',  43:'Tc',\
    44:'Ru',  45:'Rh',  46:'Pd',  47:'Ag',  48:'Cd'\
                  }
    def __init__(self,iout,fn=None,bugctrl=0):
        '''\
        Initialize variables belonged to GauIO\
        '''
        import os
        import os.path
        from os      import getcwd
        from os      import getenv
        from os.path import isfile

        from my_io   import print_Error
        from my_io   import print_String

        self.IOut	    = iout                                       # Flow of the output file
        self.IPrint	    = bugctrl                                    # to control the printing out
        self.FileName	= fn                                         # Name of the input file

        self.WorkDir    = getcwd().strip()                           # STRING, current DIR 
        self.HomeDir    = getenv('HOME')                             # STRING, Home DIR
        if getenv('IGOR_MODULES_PATH'):                              # STRING, private module DIR
            self.ModuDir=getenv('IGOR_MODULES_PATH')
        else:
            print_Error(self.IOut,
                'Error in getting grobal environment '+\
                '\"$IGOR_MODULES_PATH\" which is the direction to private modules')
         
        if self.FileName==None:
            self.f  = 'None'
            self.JobName  = 'TmpName'
            if self.IPrint>=1:
                print_String(self.IOut,
                    'Do not open input file for GauIO class',1)
        else:
            try:
                self.f 	= file(self.FileName,'r')                    # Open it
            except IOError:
                self.f  = file('Error_%s' %self.FileName,'w')
            if self.IPrint>=1:
                print_String(self.IOut,
                    'Open Gau-Input file "%s" for GauIO class'
                    % self.FileName,1)
            #
            #Generating "self.JobName" which is head of "self.FileName"
            #For example, if    self.FileName  = 'g03_1.gjf'
            #             then  self.JobName   = 'g03_1'
            path, filename  = \
                os.path.split(os.path.abspath(self.FileName))
            name, extension = os.path.splitext(filename)
            self.JobName= name                                       # Name of this job

            if bugctrl>=1:
                print_String(iout,'Enter the job : \"%s\"'
                    % self.JobName,2)


        self.MachineList= []                                         # List, machine commands
        self.OptionList	= []                                         # List, options
        self.KickOptionList=['nonstd']                               # Default disable options
        self.MoreOptionDict={'checkpoint':0,'allcheck':0,'fchk=all':0,
                'extraoverlay':0,'%chk': 0}                          # Dict., options complicated
        self.ExOvList	= []
        self.TitleList	= []                                         # List of this job title
        self.Charge	= ''                                             # Input Chage
        self.Spin	= ''                                             # Input Spin
        self.GeomList	= []                                         # Input Geometry
        self.AtLabel	= []                                         # List, Atom labels
        self.IAn	= []                                             # List, Atom indexs
        self.CList	= []                                             # List, Atom coordinates
        self.CartesianFlag=False                                     # "True"  : Cartesian
        self.ZList  = []                                             # List, Atom Z-matrix
        self.ZListR = []                                             # List, Z-matrix parameters
                                                                     # "False" : Z-Matrix;
        self.NAtom	= 0                                              # Number of atoms
        self.RestList	= []                                         # Rest content after Geometry

        self.EngyReal	= 0.0                                        # REAL, the total energy
        self.ForcList	= []                                         # LIST, Force 
        self.HessList	= []                                         # LIST, Hessian
        self.DipoList	= []                                         # List, Dipole
        self.DpDvList	= []                                         # List, Dipole derivatives 
        self.PolaList	= []                                         # List, Polarizability
        return

    def __del__(self):
        '''Close the document flow of input file'''
        from my_io   import print_String
        if self.f=='None':
            if self.IPrint>=2:
                print_String(self.IOut,
                    'Do not close input file for GauIO class',1)
        else:
            if self.IPrint>=2:
                print_String(self.IOut,
                    'Close Gau-Input file "%s" for GauIO class'
                    % self.FileName,1)
            self.f.close()                                           # Close input file
        return

    def get_MachAndOpt(self):
        '''Loading machine commands and initial options from input file\n\
  Note: the file flow locates in the next blank line below options\n\
 '''
        from my_io      import print_Error
        from my_io      import print_List
        from my_io      import print_String
        line=self.f.readline().strip()
        if len(line)==0:
            print_Error(self.IOut,
                'Error occurs in reading option keywords from' +\
                ' "%s". Please make it valid ' % self.FileName)
        while line[0]=='%':                                          # Machine commands first
            self.MachineList.append(line)
            line=self.f.readline().strip()
            if len(line)==0:
                print_Error(self.IOut,
                'Error occurs in reading option keywords from' +\
                ' "%s". Please make it valid ' % self.FileName)
        if line[0]=='#':                                             # Then for options
            TmpOptions=[]
            TmpOptions=line[1:].strip().split()
            for option in TmpOptions:
                self.OptionList.append(option)
            line=self.f.readline().strip()
            while len(line)!=0:
                TmpOptions=[]
                TmpOptions=line.strip().split()
                for option in TmpOptions:
                    self.OptionList.append(option)
                line=self.f.readline().strip()
        else:
            print_Error(self.IOut,
                'Error occurs in reading option keywords from' +\
                ' "%s". Please make it valid ' % self.FileName)

        for option in self.MachineList:                              # Get the name of chkfile
            if option.lower().find('%chk')!=-1:
                TmpList		=\
                    option.strip().split('=')[1].split('.')
                if len(TmpList)==2:
                    self.ChkName= TmpList[0]
                else:
                    self.ChkName= '.'.join(TmpList[0:-1])
                break
        else:
            self.MoreOptionDict['%chk'] = 1                          # Avoid unrequired chkfile
                                                                     # copy back
            self.ChkName	= self.JobName
            self.MachineList.insert(0,
                '='.join(['%chk','%s.chk' % self.ChkName]))
        if self.IPrint>=2:
            print_String(self.IOut,
                'ChkName is %s.chk' % self.ChkName,1)
            if len(self.MachineList)>0:
                print_List(self.IOut,self.MachineList,2,
                    'Machine commands(%s) :' % len(self.MachineList))
            print_List(self.IOut,self.OptionList,3, 
                'Job options(%s) :' % len(self.OptionList))
        return
    def ctrl_Option(self):
        '''\
        Analysis the Options.\n\
            1) "self.KickOptionList" shall be specified before this function\n\
            2) "self.MoreOptionList" will be specified in this function\n\
            3) "self.ExOvLayList"    will be loaded, if the option of "extraoverlay" exists\
        '''
        from my_io import print_Error
        from my_io import print_List
        #
        #First to kick out some specifical option which could not be
        #handled in this version
        #
        if self.IPrint>=2:
            if len(self.KickOptionList)>0:
                print_List(self.IOut,self.KickOptionList,3,
                    'KickOptionList(%s) :' % len(self.KickOptionList))
        if len(self.KickOptionList)>0:
            for option in self.OptionList:
                for ivdmd in self.KickOptionList:
                    tmp1=option.lower()
                    if tmp1.find(ivdmd)!=-1:
                        print_Error(self.IOut,
                            'Invalid option(%s) is found in gausian'\
                            %ivdmd + ' input file.')
        #
        #Then to determine the complicated option initialization
        #
        for key,value in self.MoreOptionDict.items():
            self.MoreOptionDict[key]=0
        for key,value in self.MoreOptionDict.items():
            for option in self.OptionList:
                if option.lower().find(key)!=-1:
                    self.MoreOptionDict[key]=1
        if self.MoreOptionDict['checkpoint']==1:                     # To make sure that: 
            for option in self.OptionList:                           # Check "geom=checkpoint"
                if option.find('checkpoint')!=-1:
                    if option.find('geom')!=-1:
                        self.MoreOptionDict['checkpoint']=1
                    else:
                        self.MoreOptionDict['checkpoint']=0
        #
        #Now get the addtion iop command by option "extraoverlay"
        #
        if self.MoreOptionDict['extraoverlay']==1:
            tmpExOvLay=self.f.readline().strip()
            while len(tmpExOvLay)!=0:
                self.ExOvList.append(tmpExOvLay)
                tmpExOvLay=self.f.readline().strip()
        if self.IPrint>=2:
            if len(self.ExOvList)>0:
                print_List(self.IOut,self.ExOvList,3,
                    "ExtraOverlay IOPs(%s) :" % len(self.ExOvList))
        return
    def get_TCSGR(self):
        '''Get the (T)itle, (C)harge, (S)pin, (G)eom and (R)est content from input file'''
        from re import compile
        from my_io import print_Error
        from my_io import print_String
        from my_io import print_List
        #
        # If option of "allcheck" is stated,
        #   bypass (T)(C)(S)(G) and load (R)
        #
        if self.MoreOptionDict['allcheck']==1:
            self.RestList=self.f.readlines()
            if self.IPrint>=1:
                print_String(self.IOut,
                    '\"AllCheck\" is stated, then title,charge, '+\
                    'spin and geometry are specified in CheckFile',1)
        else:
            #
            # First to get "self.TitleList" (T)
            #
            self.TitleList.append(self.f.readline().strip())
            if len(self.TitleList[0])==0:
                print_Error(self.IOut, 
                    'Missing job title in %s ' % self.FileName +\
                    '"GauIO.get_TCSGR"')
            addTitle=self.f.readline().strip()
            while len(addTitle)!=0:                                  # Read the title more row
                self.TitleList.append(addTitle)
                addTitle=self.f.readline().strip()
            if self.IPrint>=2:
                if len(self.TitleList)==1:
                    print_String(self.IOut,
                        'Title : "%s"' %self.TitleList[0],1)
                else:
                    print_List(self.IOut,self.TitleList,2,
                        'Title of job:')
            #
            # Then to get "self.Charge" (C) and "self.Spin" (S)
            #
            p1      = compile(' +|, *')
            ChargeSpin=self.f.readline().strip()
            if len(ChargeSpin)==0:
                print_Error(self.IOut, 
                    'Missing Charge and Spin in %s' % self.FileName)
            TmpList = p1.split(ChargeSpin)
            TmpList = [x.strip() for x in TmpList]
            if TmpList.count('')!=0:
                for i in range(TmpList.count('')):
                    TmpList.remove('')
            try:
                self.Charge=int(TmpList[0])
            except ValueError:
                print_Error(self.IOut, 
                    'Invalid Charge in %s' % self.FileName)
            try:
                self.Spin=int(TmpList[1])
            except ValueError:
                print_Error(self.IOut,
                    'Invalid Spin in %s' % self.FileName)
            if self.IPrint>=2:                                       # Debugging
                print_String(self.IOut, 
                    'Charge and Spin : (%d, %d)'
                    % (self.Charge, self.Spin),1)
            #
            # If option of "checkpoint" is stated,
            #  bypass "self.GeomList" (G) and load "self.RestList" (R)
            #
            if self.MoreOptionDict['checkpoint']==1:
                #self.f.readline()
                self.RestList=self.f.readlines()
                if self.IPrint>=1:
                    print_String(self.IOut,
                        '\"Geom=CheckPoint\" is specified,'+\
                        'then molecular geometry is loaded'+\
                        ' in the CheckFile',1)
                if self.IPrint>=2:
                    print_List(self.IOut,self.RestList,1)
            else:
                #
                #Then to get "self.GeomList" (G) and "self.NAtom"
                #
                self.NAtom=0
                p1      = compile(' {1,}|, {0,}')
                tmpGeom = self.f.readline().strip().replace('\t',' ')
                tmpList = [x.strip() for x in p1.split(tmpGeom)]
                for i in range(tmpList.count('')):
                    tmpList.remove('')
                if self.IPrint>=2:
                    print_List(self.IOut,tmpList,1)
                if len(tmpList)==4:                                  # To get Cartesian coordinate
                    self.CartesianFlag=True
                    if self.IPrint>=1:
                        print_String(self.IOut,
                            'Loading Cartesian coordinates',1)
                    while len(tmpList)==4:
                        self.GeomList.append(tmpGeom)
                        self.NAtom += 1
                        self.AtLabel.append(tmpList[0])
                        try:
                            self.CList.append([float(tmpList[1]),
                                float(tmpList[2]),float(tmpList[3])])
                        except ValueError:
                            print_String(self.IOut,
                            'Warning: could not get CList "GauIO.get_TCSGR"',1)
                        tmpGeom=self.f.readline().strip().replace('\t',' ')
                        tmpList     =\
                            [x.strip() for x in p1.split(tmpGeom)]
                        for i in range(tmpList.count('')):
                            tmpList.remove('')
                    else:
                        print_List(self.IOut,self.GeomList,2,
                            Info='In job=%s' %self.JobName)
                elif len(tmpList)>=5:                                # "5" : for atom fixing
                                                                     # "6" : for Onion-type input
                    self.CartesianFlag=True
                    if self.IPrint>=2:
                        print_String(self.IOut,
                            'Loading Cartesian coordinates',1)
                    while len(tmpList)>=5:
                        self.GeomList.append(tmpGeom)
                        self.NAtom += 1
                        self.AtLabel.append(tmpList[0])
                        try:
                            self.CList.append([float(tmpList[2]),
                                float(tmpList[3]),float(tmpList[4])])
                        except ValueError:
                            print_String(self.IOut,
                            'Warning: could not get CList "GauIO.get_TCSGR"',1)
                        tmpGeom=self.f.readline().strip().replace('\t',' ')
                        tmpList     =\
                            [x.strip() for x in p1.split(tmpGeom)]
                        for i in range(tmpList.count('')):
                            tmpList.remove('')
                elif len(tmpList)==1:                                # To get Z-Matrix coordinate
                    if self.IPrint>=1:
                        print_String(self.IOut,
                                'Loading Z-Matrix coordinates',1)
                    self.CartesianFlag=False
                    tmpLength=1
                    while len(tmpList)==tmpLength or \
                        len(tmpList) == 8:
                        self.GeomList.append(tmpGeom)
                        self.NAtom=self.NAtom+1
                        self.AtLabel.append(tmpList[0])
                        self.ZList.append(tmpList)
                        tmpGeom=self.f.readline().strip().replace('\t',' ')
                        tmpList     =\
                            [x.strip() for x in p1.split(tmpGeom)]
                        for i in range(tmpList.count('')):
                            tmpList.remove('')
                        if self.IPrint>=2:
                            print_List(self.IOut, tmpList,
                                3, 'Igor Debugging')
                            print_String(self.IOut, 
                                'Len is %s, meeting %s'\
                                %(tmpLength,tmpList), 2)
                        if tmpLength<7:
                            tmpLength = tmpLength+2

                    LocPos  = self.f.tell()                          # get Z-Matrix parameter
                    p1      = compile('= {0,}| {1,}|, {0,}')
                    tmpGeom=self.f.readline().strip().replace('\t',' ')
                    tmpList =\
                        [x.strip() for x in p1.split(tmpGeom)]
                    for i in range(tmpList.count('')):
                        tmpList.remove('')
                    if len(tmpList)==2:
                        tmpItem = tmpList[0].strip()
                        tmpFlag = False
                        for i in self.GeomList:
                            if i.find(tmpItem)!=-1:
                                tmpFlag = True
                                break
                        for j in self.AtLabel:
                            if j.lower().find(tmpItem.lower())!=-1:
                                tmpFlag = False
                                break
                        if tmpFlag:
                            if self.IPrint>=1:
                                print_String(self.IOut,
                                'Loading Z-Matrix parameters',
                                1)
                            while len(tmpList)==2:
                                self.ZListR.append(tmpGeom)
                                tmpGeom = self.f.readline().strip().replace('\t',' ')
                                tmpList =\
                                    [x.strip()\
                                    for x in p1.split(tmpGeom)]
                                for i in range(tmpList.count('')):
                                    tmpList.remove('')
                        else:
                            self.f.seek(LocPos)
                    else:
                        self.f.seek(LocPos)
                else:
                    print_Error(self.IOut,'Error in Geom. Info.')
  
                p1	= compile('\d+')                                 # Gen. IAn from AtLabel
                for TmpLabel in self.AtLabel:
                    if p1.match(TmpLabel[0:2]):
                        try:
                            self.IAn.append(int(TmpLabel))
                        except ValueError:
                            print_Error(self.IOut, 
                                "Error in IAn identification")
                    else:
                        TmpRe	= TmpLabel.lower()
                        for key in sorted(GauIO.AtDict.keys()):
                            if TmpRe==key:
                                self.IAn.append(GauIO.AtDict[key])
                                break
                        else:
                            print_Error(self.IOut,\
                               'Error in IAn identification')
                if self.IPrint>=2:
                    print_List(self.IOut,self.IAn,3,
                         'IAn List(%d) :' % len(self.IAn))

                self.RestList       = self.f.readlines()             # Load "self.RestList"
                if self.IPrint>=2:                                   # Debugging
                    if self.CartesianFlag:
                        print_List(self.IOut,self.GeomList,2,
                           'Cartesian Coordinate(%s)' 
                           % len(self.GeomList))
                    else:
                        print_List(self.IOut,self.GeomList,2,
                            'Z-Matrix Coordinate(%s)' 
                            % len(self.GeomList))
                        if len(self.ZListR)>0:
                            print_List(self.IOut,self.ZListR,2,
                                'Z-Matrix Parameters(%s)'
                                % len(self.ZListR))

        for i in range(len(self.RestList)):                          # filter the RestList
            self.RestList[i]=self.RestList[i].strip()
        if len(self.RestList)==0:
            pass
        elif len(self.RestList)==1:
            if len(self.RestList[0])==0:
                self.RestList   = []
        else:
            TmpIndex    = 0
            if self.RestList[0]=='' and self.RestList[1]=='':
                self.RestList = []
            else:
                while TmpIndex <= len(self.RestList)-1:
                    if self.RestList[TmpIndex]=='' and TmpIndex==0:
                        self.RestList   = self.RestList[1:]
                        TmpIndex = TmpIndex - 1
                    elif self.RestList[TmpIndex]=='' and TmpIndex!=0:
                        if self.RestList[TmpIndex-1]=='':
                            self.RestList   =\
                                self.RestList[:TmpIndex-1]
                            break
                    TmpIndex    = TmpIndex + 1
                # Fix bug for conflicting between RestList and 
                # l608 statement for R5DFT
                if self.RestList[-1].strip()=='':
                        self.RestList =\
                            self.RestList[:-1]
        if self.IPrint>=2:
            if len(self.RestList)!=0:
                print_List(self.IOut,self.RestList,2,
                    'RestList(%s):' % len(self.RestList))
                print_List(self.IOut,self.RestList,1)
        return 
    def form_Inp(self):
        '''Form gaussian input file for given statements'''
        from my_io  import print_String
        from my_io  import print_List
        #
        # Now creat a new gaussian input file
        #
        if (self.FileName!=None):
            wf=file('Job_%s.com' % self.JobName,'w')
        else:
            wf=file('%s.com' % self.ChkName,'w')
        # Form machine commands
        for line in self.MachineList:
            wf.write('%s\n' % line)
        # Input options
        self.OptionList = [x.lower() for x in self.OptionList]
        self.OptionList.insert(0,'p')
        for item in self.OptionList:
            for i in range(self.OptionList.count(item)-1):
                self.OptionList.remove(item)
                if self.IPrint>=2:
                    print_String(self.IOut,
                        'Remove option "%s"' %item,1)
        if len(self.OptionList)>10:
             self.OptionList[9]="%s\n" % self.OptionList[9]
        if len(self.OptionList)>20:
             self.OptionList[19]="%s\n" % self.OptionList[19]
        Option=' '.join(self.OptionList)
        wf.write('#%s\n' % Option)
        wf.write('\n')
        # Fill extraoverlay IOps
        if self.MoreOptionDict['extraoverlay']==1:
            for line in self.ExOvList:
                wf.write('%s\n' %line)
            wf.write('\n')
        # Write Title, Charge, Spin, Geom and Rest, if required
        if self.MoreOptionDict['allcheck']==1:                       # "Geom=AllCheck"
            for line in self.RestList:
                wf.write('%s\n' %line) 
            wf.write(' \n')
            wf.write(' \n')
        else:                                                        # Normal case and CheckPoint
            # Write the job title
            for title in self.TitleList:
                wf.write('%s\n' % title)
            wf.write('\n')
            # Write the Charge and Spin
            wf.write('%d%5d\n' %(self.Charge,self.Spin))
            if self.MoreOptionDict['checkpoint']==0:                 # For normal case
                # Write geometry info.
                for geom in self.GeomList:
                    wf.write('%s\n' %geom)
                wf.write(' \n')
                if not self.CartesianFlag and len(self.ZListR)!=0:
                    if self.IPrint>=2:
                        print_String(self.IOut,
                            'Now Loading ZListR',2)
                    for item in self.ZListR:
                        wf.write('%s\n' %item)
                    wf.write('  \n')
            else:
                wf.write(' \n')
            for line in self.RestList:
                wf.write('%s\n' % line)
            wf.write(' \n')
            wf.write(' \n')
        # Now complete the input file
        wf.close()
        return

    def update_CList(self):
        '''Update CList from GeomList'''
        from my_io  import print_Error
        from re     import compile
        self.CList	= []
        p1          = compile(' {1,}|, {0,}')
        for i in range(self.NAtom):                                  # Update CList
            TmpList =\
                [x.strip() for x in p1.split(self.GeomList[i])]
            for i in range(TmpList.count('')):
                TmpList.remove('')
            if len(TmpList)==4:
                self.CList.append([float(TmpList[1]),
                    float(TmpList[2]),float(TmpList[3])])
            elif len(TmpList)==5:
                self.CList.append([float(TmpList[2]),
                    float(TmpList[3]),float(TmpList[4])])
            else:
                print_Error(self.IOut,"Error in CList updating")
        return
    def run_GauJob(self,iop=0,sync=None):
        '''run Gaussian Job through a specified Cshell named \'Gau_Environment\'
        '''
        from os import system
        from os import mkdir
        from os import removedirs
        from os import remove
        from os import chdir
        from os import listdir
        from os.path    import exists
        from os.path    import isfile
        from os import getpid                                        # To make more then 2 jobs
                                                                     # running in one DIR
        CurrGID = getpid()
        CurrScr = './.script%s' % CurrGID
        print('Script is %s' %CurrScr)
        if not exists('%s' % CurrScr):
            mkdir('%s' % CurrScr)                                    # Creat the current work dir
        system('mv Job_%s.com %s/Job_%s.com'
            %(self.JobName, CurrScr, self.JobName))
        #if isfile('%s.chk' %self.ChkName):
        #    system('mv %s.chk %s/%s.chk'
        #        %(self.ChkName, CurrScr, self.ChkName)) 
        system('cp %s/Utility/ChkReplace.py ./ '
                % self.ModuDir)                                      # ChkReplace.py for chkpath

        if sync!=None:                                               # Message CurrScr between 
            sync.value  = '%s' % CurrScr                             #   threads

        if iop==0:                                                   # normal gaussian calculation
            system('%s/Gau_Environment %s/Job_%s.com'
                % (self.ModuDir, CurrScr, self.JobName))
        elif iop==1:                                                 # just g03, for R5DFT class
            system('%s/G03_Environment %s/Job_%s.com'
                % (self.ModuDir, CurrScr, self.JobName))
        system('mv %s/Job_%s.log Job_%s.log'
            %(CurrScr, self.JobName, self.JobName))
        #if self.MoreOptionDict['%chk']==1:                            # Do not save chk
        #    remove('%s.chk' % self.ChkName)
        remove('ChkReplace.py')
        #if self.MoreOptionDict['fchk=all']==1:                       # save Test.FChk for fchk=all
        #    system('mv %s/Test.FChk Test.FChk' % CurrScr)
        if self.IPrint<2:
            for tmpFile in listdir('%s' % CurrScr):
                remove('%s/%s' % (CurrScr,tmpFile))
            removedirs('%s' %CurrScr)
        return
    def copy_DataIO(self,DataIO):
        '''Copy all the IO data from DataIO'''
        from copy   import deepcopy
        # Initial parameters
        self.IOut           = DataIO.IOut                            # Flow
        #self.FileName       = DataIO.FileName                       # Strings
        self.ModuDir        = DataIO.ModuDir
        self.JobName        = DataIO.JobName
        self.ChkName        = DataIO.ChkName
        self.CartesianFlag  = DataIO.CartesianFlag                   # Logic
        self.IPrint         = DataIO.IPrint                          # Integers
        self.Charge         = DataIO.Charge
        self.Spin           = DataIO.Spin
        self.NAtom          = DataIO.NAtom
        self.MachineList    = DataIO.MachineList[:]                  # Lists
        self.OptionList     = DataIO.OptionList[:]
        self.TitleList      = DataIO.TitleList[:]
        self.GeomList       = DataIO.GeomList[:]
        self.IAn            = DataIO.IAn[:]
        self.AtLabel        = DataIO.AtLabel[:]
        self.CList          = DataIO.CList[:]
        self.ZList          = DataIO.ZList[:]
        self.ZListR         = DataIO.ZListR[:]
        self.RestList       = DataIO.RestList[:]
        self.MoreOptionDict = deepcopy(DataIO.MoreOptionDict)        # Dictionaries  
        return

    def copy_Geom(self,DataIO):
        '''Copy all the geom data from DataIO'''
        self.GeomList       = DataIO.GeomList[:]
        self.CList          = DataIO.CList[:]
        self.ZList          = DataIO.ZList[:]
        self.ZListR         = DataIO.ZListR[:]
        return
    def collect_Geom(self):
        '''Collect cartesian geom info from log or chk file'''
        from os     import system
        from os.path    import isfile
        from my_io  import print_Error
        from my_io  import print_String
        from my_io  import print_List

        if self.MoreOptionDict['allcheck']==1 or\
            self.MoreOptionDict['checkpoint']==1:
            if self.IPrint>=1:
                print_String(self.IOut,
                    'Geom. info. is collected from the checkfile' +\
                    ' of %s.chk' %self.ChkName,1)
            if not isfile('%s.chk' %self.ChkName):
                print_Error(self.IOut,
                    'Error in accessing %s.chk ' %self.ChkName +\
                    '"GauIO.collect_Geom"')
            system('%s/G03_Environment %s.chk'
                    %(self.ModuDir,self.ChkName))
            cf      = file('%s.fchk' %self.ChkName,'r')
            LocPos  = cf.read().find('Atomic numbers')
            cf.seek(LocPos)
            self.NAtom  = int(cf.readline().strip().split('N=')[1])
            NumLine = self.NAtom/6
            if self.NAtom%6!=0:
                NumLine += 1
            self.GeomList   = []
            self.IAn        = []
            self.AtLabel    = []
            self.CList      = []
            CList           = []
            for i in range(NumLine):
                tmpIAn      = [int(x.strip()) \
                    for x in cf.readline().strip().split()]
                self.IAn.extend(tmpIAn)
                self.AtLabel.extend(tmpIAn)
            if len(self.IAn)!= self.NAtom:
                print_Error(self.IOut,
                    'Error in \'NAtom\' detemination' +\
                    ' the length of IAn is unequal to NAtom' +\
                    ' GauIO.collect_Geom')
            cf.seek(0)
            LocPos  =\
                cf.read().find('Current cartesian coordinates')
            cf.seek(LocPos)
            cf.readline()
            NTT     = self.NAtom * 3
            NumLine = NTT/5
            if NTT%5!=0:
                NumLine += 1
            for i in range(NumLine):
                tmpCList    = [float(x.strip()) \
                    for x in cf.readline().strip().split()]
                CList.extend(tmpCList)
            if len(CList) != NTT:
                print_Error(self.IOut,
                    'Error in CList loading from chkfile' +\
                    ' the length of CList is unequal NTT.' +\
                    ' "GauIO.collect_Geom"')
            tmpI    = 0
            for i in range(self.NAtom):
                self.CList.append([CList[tmpI],
                    CList[tmpI+1],CList[tmpI+2]])
                self.GeomList.append('%2d%16.8f%16.8f%16.8f'
                        % (self.IAn[i],self.CList[i][0],\
                        self.CList[i][1],self.CList[i][2]))
                tmpI    += 3
            if len(self.CList) != self.NAtom:
                print_Error(self.IOut,
                    'Error in self.CList loading from chkfile')
            if self.IPrint>=2:
                print_List(self.IOut,self.GeomList,2,
                    'Obtained geom. from %s.chk' % self.ChkName)
            cf.close()
            self.CartesianFlag  = True
        else:
            if self.IPrint>=1:
                print_String(self.IOut,
                    'Collecting geom. info. from logfile',1)
            from os         import getpid
            import copy
            tmpInp      = 'Igor%s' % getpid()                        # Form tmp gau-input
            wf          = file('%s.com' %tmpInp,'w') 
            tmpList     = ['#P','NonStd\n','1//1;\n','2//2;']
            tmpOption   = ' '.join(tmpList)
            wf.write('%s\n' %tmpOption)
            wf.write(' \n')
            wf.write('Get Geom\n')
            wf.write(' \n')
            wf.write('%d%5d\n' %(self.Charge,self.Spin))
            for item in self.GeomList:
                wf.write('%s\n' % item)
            wf.write(' \n')
            if len(self.ZListR)!=0:
                for item in self.ZListR:
                    wf.write('%s\n' % item)
                wf.write(' \n')
            for item in self.RestList:
                wf.write('%s\n' % item)
            wf.write(' \n')
            wf.write(' \n')
            wf.close()
                                                                     # Run tmp gaussian job
            system('%s/Gau_Environment %s.com'
                % (self.ModuDir,tmpInp))
            try:
                lf          = file('%s.log' %tmpInp,'r')
            except IOError:
                print_Error(self.IOut,
                    'Error happens in opening %s.log'\
                    % tmpInp)
            LocPos      = lf.read().find('Standard orientation:')
            try:
                lf.seek(LocPos)
            except IOError:
                print_String(self.IOut,
                    'Error happens in getting '+\
                    '"Standard orientation" from %s.log'\
                    % tmpInp,1)
                lf.seek(0)
                print_Error(self.IOut,lf.read())
            i           = 0
            for i in range(5):
                lf.readline()
            TmpGeom     = lf.readline().strip().split()
            self.NAtom  = 0
            self.IAn    = []
            while len(TmpGeom) == 6:
                self.IAn.append(int(TmpGeom[1]))
                self.CList.append([float(TmpGeom[3]),
                    float(TmpGeom[4]),float(TmpGeom[5])])
                self.NAtom += 1
                TmpGeom     = lf.readline().strip().split()
            GeomList        = []
            for i in range(self.NAtom):
                GeomList.append('%3s%16.8f%16.8f%16.8f'
                    %(GauIO.AnDict[self.IAn[i]],self.CList[i][0],\
                    self.CList[i][1],self.CList[i][2]))
            self.GeomList  = copy.copy(GeomList)
            if self.IPrint>=2:
                print_List(self.IOut,self.GeomList,2,
                    'Obtained Geom. from logfile')
            lf.close()
            system('rm %s.log %s.com' % (tmpInp,tmpInp))
            self.CartesianFlag  = True
            self.ZListR         = []
        return

class ChkHandle:
    '''Collect results required from ChF of Gaussian package'''

    def __init__(self,iout,GauIO,bugctrl=0): 
        '''\
        Initialize variables belonged to ChkHandle\
        '''
        from os      import system
        from os      import getcwd
        from os      import getenv
        from os.path import isfile
        from my_io   import print_String
        self.IOut       = iout                                       # FLOW of output file
        self.GauIO      = GauIO                                      # gaussian_manage.GauIO class
        self.IPrint     = bugctrl                                    # INTEGER, printting control
        self.WorkDir    = getcwd().strip()                           # STRING, current DIR 
        self.HomeDir    = getenv('HOME')                             # STRING, Home DIR
        if getenv('IGOR_MODULES_PATH'):                              # STRING, private module DIR
            self.ModuDir=getenv('IGOR_MODULES_PATH')
        else:
            print_Error(self.IOut,
                'Error in getting the grobal environment '+\
                '\"$IGOR_MODULES_PATH\" which is the direction to private modules')

        if GauIO.MoreOptionDict['extraoverlay']!=1:
            system('%s/Gau_Environment %s.chk'
                % (self.ModuDir,GauIO.ChkName))
        elif GauIO.MoreOptionDict['extraoverlay']==1:
            system('%s/G03_Environment %s.chk'
                % (self.ModuDir,GauIO.ChkName))
        try:
            self.rf     = file('%s.fchk' % GauIO.ChkName,'r')        # FLOW, fchk of Job
        except IOError:
            self.rf     = file('Error_%s.fchk' % GauIO.ChkName,'w')
            print_String(self.rf,
                '%s.fchk could not be found' % GauIO.ChkName,2)
            print_String(self.IOut,
                '%s.fchk could not be found' % GauIO.ChkName,2)
            self.rf.close()
            self.rf     = file('Error_%s.fchk' % GauIO.ChkName,'r')

        self.ChkName    = GauIO.ChkName
        self.EngyReal   = 0.0                                        # REAL, the total energy
        self.EngyList   = []
        self.ForcList   = []                                         # LIST, Force
        self.HessList   = []                                         # LIST, Hessian 
        self.DipoList   = []                                         # List, Dipole
        self.DpDvList   = []                                         # List, Dipole derivatives
        self.PolaList   = []                                         # List, Polarizability
        self.HyPoList   = []                                         # List, HyperPolarizability
        self.IAn        = []
        self.AtLabel    = []
        self.CList      = []
        self.GeomList   = []
        return

    def __del__(self):
        self.rf.close()
        return
    def collect_EngyReal(self):
        '''\
        Collect the total energy from gaussian check file Store in self.ElecEngy\
        '''
        from my_io import print_String
        self.rf.seek(0)
        LocPos		= self.rf.read().find('Total Energy')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.EngyReal	= \
            float(self.rf.readline().strip().split('R')[1])
            if self.IPrint>=1:
                print_String(self.IOut,
                    'QM Energy       =  %18.8E (A.U.)' % self.EngyReal,1)
        else:
            self.EngyReal   = 'NAN'
            if self.IPrint>=0:
                print_String(self.IOut,
                    'Could not find QM energy from %s.fchk'
                    % self.ChkName,1)

        self.rf.seek(0)                                             # Print SCF energy
        LocPos		= self.rf.read().find('SCF Energy')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            SCFReal	= \
            float(self.rf.readline().strip().split('R')[1])
            if self.IPrint>=1:
                print_String(self.IOut,
                    'SCF Energy      =  %18.8E (A.U.)' % SCFReal,1)
                print_String(self.IOut,
                    'post-SCF Energy =  %18.8E (A.U.)' % (self.EngyReal-SCFReal),1)
        return self.EngyReal
    def collect_ForcList(self):
        '''Collect the force from gaussian check file\n\
        Store in self.ForcList'''
        from my_io import print_List
        self.ForcList	= []
        NTT		= self.GauIO.NAtom*3
        self.rf.seek(0)
        LocPos          = self.rf.read().find('Cartesian Gradient')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            NumLine		= NTT/5
            if (NTT%5)>0:
                NumLine	= NumLine+1
            TmpLine		= 1
            while TmpLine<=NumLine:
                TmpLine	= TmpLine+1
                TmpList	= self.rf.readline().strip().split()
                for i in TmpList:
                    self.ForcList.append(float(i))
            if self.IPrint>=2:
                print_List(self.IOut,self.ForcList,4,
                    'Cartesian Gradient (%d) from \'%s.fchk\':'
                    %(len(self.ForcList),self.ChkName))
        else:
            self.ForcList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut,
                    'Could not found Cartesian Gradient'+\
                    ' from \'%s.fchk\':'
                    %(self.ChkName),1)
        return
    def collect_HessList(self):
        '''Collect the Hessian from gaussian check file\n\
        Store in self.HessList'''
        from my_io import print_List
        self.HessList	= []
        NTT		= (self.GauIO.NAtom*3+1)*self.GauIO.NAtom*3/2
        self.rf.seek(0)
        LocPos	= self.rf.read().find('Cartesian Force Constants')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            NumLine         = NTT/5
            if (NTT%5)>0:
                NumLine     = NumLine+1
            TmpLine         = 1
            while TmpLine<=NumLine:
                TmpLine     = TmpLine+1
                TmpList     = self.rf.readline().strip().split()
                for i in TmpList:
                    self.HessList.append(float(i)) 
            if self.IPrint>=2:
                print_List(self.IOut,self.HessList,4, 
                    'Cartesian Force Constants (%s) from "%s.fchk":'
                    % (len(self.HessList),self.ChkName))
        else:
            self.HessList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut,
                    'Could not found Cartesian Force Constants'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)
        return
    def collect_Dipole(self):
        '''Collect Dipole, Dipole derivatives and Polarizability\
        from gaussian check file\n\
        Store in self.DipoList, self.DpDvList, self.PolaList'''
        from my_io import print_List
        NTT		= 3                                                  # At first, for dipole
        self.DipoList   = []
        self.rf.seek(0)
        LocPos  = self.rf.read().find('Dipole Moment')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            TmpList=self.rf.readline().strip().split()
            for i in TmpList:
                self.DipoList.append(float(i))
            if self.IPrint>=2:
                print_List(self.IOut,self.DipoList,4,
                    'Dipole Monent (%s) from \'%s.fchk\':'
                    % (len(self.DipoList),self.ChkName))
        else:
            self.DipoList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found Dipole Moment'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)

        NTT		= self.GauIO.NAtom*3*3                               # Then, for dipole derivative
        self.DpDvList	= []
        self.rf.seek(0)
        LocPos  = self.rf.read().find('Dipole Derivatives')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            NumLine         = NTT/5
            if (NTT%5)>0:
                NumLine     = NumLine+1
            TmpLine         = 1
            while TmpLine<=NumLine:
                TmpLine     = TmpLine+1
                TmpList     = self.rf.readline().strip().split()
                for i in TmpList:
                    self.DpDvList.append(float(i))
            if self.IPrint>=2:
                print_List(self.IOut,self.DpDvList,4,
                    'Dipole Derivatives (%s) form \'%s.fchk\':'
                    % (len(self.DpDvList),self.ChkName))
        else:
            self.DpDvList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found Dipole Derivatives'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)

        NTT             = 6                                          # Finally, for polarizability
        self.PolaList	= []
        self.rf.seek(0)
        LocPos		= self.rf.read().find('Polarizability     ')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            NumLine		= 2
            TmpLine		= 1
            while TmpLine<=NumLine:
                TmpLine     = TmpLine+1
                TmpList     = self.rf.readline().strip().split()
                for i in TmpList:
                    self.PolaList.append(float(i))
            if self.IPrint>=2:
                print_List(self.IOut,self.PolaList,4,
                    'Polarizability (%s) from \'%s.fchk\':'
                    % (len(self.PolaList),self.ChkName))
        else:
            self.PolaList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found Polarizability'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)
        return
    def collect_ElecResp(self):
        '''Collect Dipole, Polarizability, HyperPolarizability\n\
        Store in DipoList, PolaList, HyPoList'''
        DipoScal    = 0.39343

        from my_io import print_List
        from my_io import print_String
        NTT		= 3                                                  # At first, for dipole
        self.DipoList	= []
        self.rf.seek(0)
        LocPos  = self.rf.read().find('Dipole Moment')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            TmpList=self.rf.readline().strip().split()
            for i in TmpList:
                self.DipoList.append(float(i))
            if self.IPrint>=2:
                print_List(self.IOut,self.DipoList,4,
                    'Dipole Monent (%s) from \'%s.fchk\':'
                    % (len(self.DipoList),self.ChkName))
        else:
            self.DipoList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found Dipole Moment'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)

        NTT     = 6                                                  # for polarizability
        self.PolaList	= []
        self.rf.seek(0)
        LocPos  = self.rf.read().find('Polarizability     ')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            NumLine		= 2
            TmpLine		= 1
            while TmpLine<=NumLine:
                TmpLine     = TmpLine+1
                TmpList     = self.rf.readline().strip().split()
                for i in TmpList:
                    self.PolaList.append(float(i))
            if self.IPrint>=2:
                print_List(self.IOut,self.PolaList,4,
                    'Polarizability (%s) from \'%s.fchk\':'
                    % (len(self.PolaList),self.ChkName))
        else:
            self.PolaList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found Polarizability'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)

        NTT     = 10                                                 # for hyperpolarizability
        self.HyPoList   = []
        self.rf.seek(0)
        LocPos  = self.rf.read().find('HyperPolarizability     ')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            NumLine     = 2
            TmpLine     = 1
            while TmpLine<=NumLine:
                TmpLine     = TmpLine+1
                TmpList     = self.rf.readline().strip().split()
                for i in TmpList:
                    self.HyPoList.append(float(i))
            if self.IPrint>=2:
                print_List(self.IOut,self.HyPoList,4,
                    'HyperPolarizability (%s) from \'%s.fchk\':'
                    % (len(self.HyPoList),self.ChkName))
        else:
            self.HyPoList   = ['NAN']*NTT
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found HyperPolarizability'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)

        return
    def collect_Geom(self):
        '''Collect geom information from check file'''
        from my_io          import print_Error
        from my_io          import print_String
        from my_io          import print_List

        if self.IPrint>=1:
            print_String(self.IOut,
                'Geom. info. is collected from the checkfile' +\
                ' of %s.chk' %self.ChkName,1)
        self.rf.seek(0)
        LocPos  = self.rf.read().find('Atomic numbers')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.GauIO.NAtom  =\
                int(self.rf.readline().strip().split('N=')[1])
            NumLine = self.GauIO.NAtom/5
            if self.GauIO.NAtom%5!=0:
                NumLine += 1
            self.IAn        = []
            self.AtLabel    = []
            for i in range(NumLine):
                tmpIAn      = [int(x) \
                    for x in self.rf.readline().split()]
                self.IAn.extend(tmpIAn)
                self.AtLabel.extend(tmpIAn)
        else:
            self.IAn        = 'NAN'
            self.AtLabel    = 'NAN'
            self.CList      = 'NAN'
            self.GeomList   = 'NAN'
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found Geom. Info.'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)
            return
        self.rf.seek(0)
        LocPos  =\
            self.rf.read().find('Current cartesian coordinates')
        if LocPos!=-1:
            CList           = []
            self.CList      = []
            self.GeomList   = []
            self.rf.seek(LocPos)
            self.rf.readline()
            NTT     = self.GauIO.NAtom * 3
            NumLine = NTT/5
            if NTT%5!=0:
                NumLine += 1
            for i in range(NumLine):
                tmpCList    = [float(x) \
                    for x in self.rf.readline().strip().split()]
                CList.extend(tmpCList)
            tmpI    = 0
            for i in range(self.GauIO.NAtom):
                self.CList.append([CList[tmpI],
                    CList[tmpI+1],CList[tmpI+2]])
                self.GeomList.append('%2d%16.8f%16.8f%16.8f'
                        % (self.IAn[i],self.CList[i][0],\
                        self.CList[i][1],self.CList[i][2]))
                tmpI    += 3
            if len(self.CList) != self.GauIO.NAtom:
                print_Error(self.IOut,
                    'Error in self.CList loading from chkfile')
            if self.IPrint>=1:
                print_List(self.IOut,self.GeomList,2,
                    'Obtained Geom. from %s.chk' % self.ChkName)
            self.rf.close()
        else: 
            self.IAn        = 'NAN'
            self.AtLabel    = 'NAN'
            self.CList      = 'NAN'
            self.GeomList   = 'NAN'
            if self.IPrint>=1:
                print_String(self.IOut, 
                    'Could not found Geom. Info.'+\
                    ' from "%s.fchk":'
                    % (self.ChkName),1)
            return
        return

class LogHandle:
    '''\
    Collect required results from log file of Gaussian package\
    Especially for R5DFT calculation.
    '''

    def __init__(self,iout,GauIO,bugctrl=0):
        '''\
        Initialize variables belonged to LogHandle\
        '''
        self.IOut       = iout                                       # FLOW, output file
        self.GauIO      = GauIO                                      # CLASS gaussian_manage.GauIO
        self.JobName    = 'Job_%s' %GauIO.JobName
        self.IPrint     = bugctrl                                    # INTEGER, printting control

        self.rf	        = file('Job_%s.log' %GauIO.JobName,'r')      # FLOW, log of Job
        self.EngyReal	= 0.0
        self.EngyNoMP2  = 0.0
        self.Ex_HF      = 0.0
        self.Ex_LDA     = 0.0
        self.Ex_dGGA    = 0.0
        self.Ec_LDA     = 0.0
        self.Ec_dGGA    = 0.0
        self.EngyNoXC   = 0.0
        self.Ec_MP2     = [0.0]*3

        self.EngyList   = []                                         # SCF-Done energy list

        self.AtLabel    = []
        self.CList      = []
        self.NAtom      = 0
        self.GeomList   = []
        return
    def __del__(self):
        self.rf.close()
        return
    def collect_DFT_0(self,methodflag='b3lyp'):
        '''Collect each energy terms of DFT method'''
        # LogFile of single point calculation is valid but not geometry optimization job
        from my_io 	import print_List
        from my_io 	import print_String
        from my_io 	import print_Error
        from re		import compile
        if methodflag.lower().strip().find('b3lyp') != -1:
            self.rf.seek(0)
            LocPos  = self.rf.read().find('B+HF-LYP) =')
            if LocPos!=-1:
                self.rf.seek(LocPos)
                SCFDoneList     = self.rf.readline().split()
                EqualIndex      = SCFDoneList.index('=')+1
                #**#
                self.EngyReal   = float(SCFDoneList[EqualIndex])     # B3LYP energy
                #**#
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return
            LocPos  = self.rf.read().find('ENTVJ')
            if LocPos!=-1:
                self.rf.seek(LocPos)
                p1      = compile('ENTVJ|Ex=|Ec=|ETotM2e=|ETot=')
                LDAList = p1.split(self.rf.readline())
                #**#
                self.EngyNoMP2  = float(LDAList[5])                  # Truncated DFT energy
                #**#
                if self.IPrint>=2:
                    TmpList	= [ 
                        'E_B3LYP     = %10.5f  EngyNoMP2   = %10.5f' 
                        % (self.EngyReal, self.EngyNoMP2)
                              ]
                    print_List(self.IOut,TmpList,2)
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return
        return
    def collect_DFT(self,methodflag='b3lyp',iflag='routine'):        # routine : not get all terms
        '''Collect each energy terms of DFT method'''                # develop : include all terms
        # LogFile of single point calculation is valid but not geometry optimization job
        from my_io 	import print_List
        from my_io 	import print_String
        from my_io 	import print_Error
        from re		import compile
        if (methodflag.lower().strip().find('b3lyp') != -1) and\
          (iflag=='develop'):
            LocPos=self.rf.read().find('B+HF-LYP) =')
            if LocPos!=-1:
                self.rf.seek(LocPos)
                SCFDoneList         = self.rf.readline().split()
                EqualIndex          = SCFDoneList.index('=')+1
                #**#
                self.EngyReal   = float(SCFDoneList[EqualIndex])     # B3LYP energy
                #**#
                AfterIndex      = SCFDoneList.index('after')+1
                CycNum          = SCFDoneList[AfterIndex]            # Cycle Number of SCF
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                self.Ex_LDA     = 'NAN' 
                self.Ec_LDA     = 'NAN' 
                self.Ex_HF      = 'NAN'  
                self.Ex_dGGA    = 'NAN' 
                self.Ec_dGGA    = 'NAN' 
                self.EngyNoXC   = 'NAN' 
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.(B+HF-LYP)'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return
            self.rf.seek(0)
            LocPos  = self.rf.read(LocPos).find('Cycle%4s' %CycNum)
            if LocPos!=-1:
                self.rf.seek(LocPos)
                self.rf.readline()
                while True:
                    Cycle       = self.rf.readline().strip()
                    if Cycle.find('One-electron energy')!=-1:
                        Cycle   = 'E'.join(Cycle.split('D'))
                        HatrNum = float(Cycle.split('=')[1])         # Get hatree energy of B3LYP
                    elif Cycle.find('1/2 <PJ(P)>')!=-1:
                        ClmbNum	= float(Cycle.split('=')[1])         # Get colomb energy of B3LYP
                    elif Cycle.find('Ex=')!=-1:
                        p1      = compile('Ex=|Ec=')
                        ExNum   = float(p1.split(Cycle)[1])          # Get B3LYP exchange energy
                        EcNum   = float(p1.split(Cycle)[2])          # Get correlation energy
                        break
                else:
                    self.EngyReal   = 'NAN'
                    self.EngyNoMP2  = 'NAN'
                    self.Ex_LDA     = 'NAN' 
                    self.Ec_LDA     = 'NAN' 
                    self.Ex_HF      = 'NAN'  
                    self.Ex_dGGA    = 'NAN' 
                    self.Ec_dGGA    = 'NAN' 
                    self.EngyNoXC   = 'NAN' 
                    if self.IPrint>=0:
                        print_String(self.IOut, 
                            'Could not found Engy. Info.'+\
                            ' from "%s.log":'
                            % (self.GauIO.JobName),1)
                    return
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                self.Ex_LDA     = 'NAN' 
                self.Ec_LDA     = 'NAN' 
                self.Ex_HF      = 'NAN'  
                self.Ex_dGGA    = 'NAN' 
                self.Ec_dGGA    = 'NAN' 
                self.EngyNoXC   = 'NAN' 
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return

            self.rf.seek(LocPos)
            LocPos          = self.rf.read().find('EJ=')         # Get LDA terms from l608
            if LocPos!=-1:
                self.rf.seek(LocPos)
                p1          = compile('EJ=|EK=')
                TmpLine     = self.rf.readline().strip()
                LDAClmbNum  = float(p1.split(TmpLine)[1])        # Absolute Colomb energy
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                self.Ex_LDA     = 'NAN' 
                self.Ec_LDA     = 'NAN' 
                self.Ex_HF      = 'NAN'  
                self.Ex_dGGA    = 'NAN' 
                self.Ec_dGGA    = 'NAN' 
                self.EngyNoXC   = 'NAN' 
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return
            self.rf.seek(0)
            LocPos  = self.rf.read().find('ENTVJ')
            if LocPos!=-1:
                self.rf.seek(LocPos)
                p1              = compile('ENTVJ|Ex=|Ec=|ETotM2e=')
                LDAList         = p1.split(self.rf.readline())
                #**#
                self.Ex_LDA     = float(LDAList[2])                  # Ex_LDA
                self.Ec_LDA     = float(LDAList[3])                  # Ec_LDA
                self.Ex_HF      = (ClmbNum-LDAClmbNum)/0.2           # Exact Exchange term
                self.Ex_dGGA    = (ExNum-self.Ex_LDA*0.80)/0.72      # Ex_dGGA terms
                self.Ec_dGGA    = (EcNum-self.Ec_LDA)/0.81           # Ec_dGGA terms
                self.EngyNoXC   = self.EngyReal\
                                       - 0.20*self.Ex_HF\
                                       - 0.80*self.Ex_LDA\
                                       - 0.72*self.Ex_dGGA\
                                       - 1.00*self.Ec_LDA\
                                       - 0.81*self.Ec_dGGA
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                self.Ex_LDA     = 'NAN' 
                self.Ec_LDA     = 'NAN' 
                self.Ex_HF      = 'NAN'  
                self.Ex_dGGA    = 'NAN' 
                self.Ec_dGGA    = 'NAN' 
                self.EngyNoXC   = 'NAN' 
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return
            #**#
            if self.IPrint>=2:
                TmpList	= [\
                    'E_B3LYP     = %10.5f  EngyNoXC    = %10.5f'\
                    % (self.EngyReal, self.EngyNoXC),\
                    'Ex_HF       = %10.5f' \
                    % self.Ex_HF,\
                    'Ex_LDA      = %10.5f  Ex_dGGA     = %10.5f'\
                    % (self.Ex_LDA,self.Ex_dGGA),\
                    'Ec_LDA      = %10.5f  Ec_dGGA     = %10.5f'\
                    %  (self.Ec_LDA,self.Ec_dGGA)\
                          ]
                print_List(self.IOut,TmpList,2)
        elif (methodflag.lower().strip().find('b3lyp') != -1) and\
          (iflag=='routine'):
            self.rf.seek(0)
            LocPos  = self.rf.read().find('B+HF-LYP) =')
            if LocPos!=-1:
                self.rf.seek(LocPos)
                SCFDoneList     = self.rf.readline().split()
                EqualIndex      = SCFDoneList.index('=')+1
                #**#
                self.EngyReal   = float(SCFDoneList[EqualIndex])     # B3LYP energy
                #**#
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return
            self.rf.seek(0)
            LocPos          = self.rf.read().find('ENTVJ')
            if LocPos!=-1:
                self.rf.seek(LocPos)
                p1              =\
                    compile('ENTVJ|Ex=|Ec=|ETotM2e=|ETot=')
                LDAList         = p1.split(self.rf.readline())
                #**#
                self.EngyNoMP2  = float(LDAList[5])                  # Truncated DFT energy
                #**#
            else:
                self.EngyReal   = 'NAN'
                self.EngyNoMP2  = 'NAN'
                if self.IPrint>=0:
                    print_String(self.IOut, 
                        'Could not found Engy. Info.'+\
                        ' from "%s.log":'
                        % (self.GauIO.JobName),1)
                return
            if self.IPrint>=2:
                TmpList	= [ 
                    'E_B3LYP     = %10.5f  EngyNoMP2   = %10.5f' 
                    % (self.EngyReal, self.EngyNoMP2)
                          ]
                print_List(self.IOut,TmpList,2)
        return
    def collect_MP2(self):
        '''Collect MP2 energies from Log file'''
        from my_io	import print_List
        from my_io	import print_String
        from gaussian_manage import GauIO
        self.rf.seek(0)
        LocPos		=\
            self.rf.read().find('Spin components of T(2) and E(2):')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            self.rf.readline()
            self.Ec_MP2[0]	=\
                float('E'.join(self.rf.readline()[48:].split('D')))
            self.Ec_MP2[1]	=\
                float('E'.join(self.rf.readline()[48:].split('D')))
            self.Ec_MP2[2]	=\
                float('E'.join(self.rf.readline()[48:].split('D')))
        else:
            self.Ec_MP2[0]  = 'NAN'
            self.Ec_MP2[1]  = 'NAN'
            self.Ec_MP2[2]  = 'NAN'
            if self.IPrint>=0:
                print_String(self.IOut, 
                    'Could not found MP2 Engy. Info.'+\
                    ' from "%s.log":'
                    % (self.GauIO.JobName),1)
            return
        if self.IPrint>=2:
            TmpList	= [\
                'Ec_MP2(alpha-alpha)   = %16.8f' % self.Ec_MP2[0],\
                'Ec_MP2(alpha-beta)    = %16.8f' % self.Ec_MP2[1],\
                'Ec_MP2(beta-beta)     = %16.8f' % self.Ec_MP2[2]]
            print_List(self.IOut,TmpList,2)
        return
    def collect_EngyReal(self,iop=0):                                # iop=1  : get energy list
        '''Collect SCF-Done energes from Log file'''                 #          self.EngyList 
        from my_io      import print_String                          # 0 or 2 : get the last one
        from my_io      import print_Error                           #          self.EngyReal
        from my_io      import print_List
        from re         import compile
        self.IOut.flush()
        self.rf.seek(0)
        TmpFile     = self.rf.read()
        NEngy       = TmpFile.count('SCF Done:  E(')
        if NEngy==0:
            if iop==0 or iop==2:
                self.EngyReal   = 'NAN'
            elif iop==1:
                self.EngyList   = 'NAN'*1
            return
        LocPos      = 0
        if self.IPrint>=2:
            print_String(self.IOut,
                'There are %3d SCF-Done energies in the log file'
                % NEngy,1)
        for i in range(NEngy-1):
            LocPos  = TmpFile.find('SCF Done:  E(',LocPos+1)
            if iop==1:
                self.rf.seek(LocPos)
                try:
                    TmpEngy =\
                    float(self.rf.readline().strip().split()[4])
                except ValueError:
                    print_String(self.IOut,
                        'Error in collecting SCF-Done energy '+\
                        '\"LogHandle.collect_EngyReal\"',2)
                    TmpEngy = 'NAN'
                self.EngyList.append(TmpEngy)
        LocPos      = TmpFile.find('SCF Done:  E(',LocPos+1)
        self.rf.seek(LocPos)
        try:
            TmpEngy =\
                float(self.rf.readline().strip().split()[4])
            if iop==0 or iop==2:
                self.EngyReal   = TmpEngy
            elif iop==1:
                self.EngyList.append(TmpEngy)
        except ValueError:
            print_String(self.IOut,
                'Error in collecting SCF-Done energy '+\
                '\"LogHandle.collect_EngyReal\"',2)
            if iop==0 or iop==2:
                self.EngyReal   = 'NAN'
            elif iop==1:
                self.EngyList.append('NAN')
        return

    def collect_Geom(self):
        '''\
        collect Input Cartesian geom from log file\
        '''
        import copy
        self.rf.seek(0)
        LocPos      = self.rf.find('Standard orientation:')
        if LocPos!=-1:
            self.rf.seek(LocPos)
            i           = 0
            for i in range(5):
                self.rf.readline()
            TmpGeom     = self.rf.readline().strip().split()
            NAtom       = 0
            while len(TmpGeom) == 6:
                IAn.append(int(TmpGeom[1]))
                CList.append([float(TmpGeom[3]),
                    float(TmpGeom[4]),float(TmpGeom[5])])
                NAtom += 1
                TmpGeom    = self.rf.readline().strip().split()
            self.NAtom     = NAtom
            self.IAn       = IAn[:]
            self.GeomList  = []
            for i in range(NAtom):
                self.GeomList.append('%3d%10.5f%10.5f%10.5f'
                    %(IAn[i],CList[i][0],CList[i][1],CList[i][2]))
        else:
            self.NAtom      = 'NAN'
            self.IAn        = 'NAN'
            self.GeomList   = 'NAN'
            if self.IPrint>=1:
                print_String(self.IOut, 
                    'Could not found Geom. Info.'+\
                    ' from "%s.log":'
                    % (self.GauIO.JobName),1)
        return
    def collect_Geom_converged(self):
        '''\
        collect converged geometry information\
        '''
        from os     import remove
        from re     import compile
        from my_io  import print_List_free
        from my_io  import print_String
        from my_io  import print_List
        #===================#
        # To split link jobs#
        #===================#
        P0      = compile('Proceeding to internal job step number')
        P1      = compile('Threshold *Converged\? *\\n')
        P2      = compile('Standard orientation: *\\n')
        P3      = compile('Charge = *(\d) Multiplicity = *(\d)')
        P4      = compile('Zero-point correction= *(\d+.\d+)')
        P5      = compile('Thermal correction to Enthalpy= *(\d+.\d+)')
        self.rf.seek(0)
        TmpString = self.rf.read()
        TmpList = P0.split(TmpString)
        if len(TmpList)==2:
            Sta, End = P0.search(TmpString).span()
            CMFit   = P3.search(TmpString[End:])
            if CMFit:
                print_String(self.IOut,'%s' %CMFit.group(0),1)
                print_String(self.IOut,'There are %3i atoms in this molecule' %self.GauIO.NAtom,1)
                Sta1, End1 = CMFit.span()
                self.rf.seek(End+Sta1)
                self.rf.readline()
                CList = []
                for x in range(self.GauIO.NAtom):
                    TmpList = self.rf.readline().strip().split(',')
                    try:
                        CList.append([TmpList[0]]+[float(xx) for xx in TmpList[2:]])
                    except:
                        CList.append([TmpList[0]]+['NAN']*3)
                FormList=['%5s%16.8f%18.8f%18.8f','%5s%16s%16s%16s']
                print_List_free(self.IOut,CList,1,FormList)
            ZPEFit  = P4.search(TmpString)
            if ZPEFit:
                print_String(self.IOut,'%s' %ZPEFit.group(0),1)
            TCEFit = P5.search(TmpString)
            if TCEFit:
                print_String(self.IOut,'%s' %TCEFit.group(0),1)
            return (True,CList)
        else:
            print_String(self.IOut,'No ZPE and TCE in this job',1)
            tf      = file('tmp.log','w')
            tf.write(TmpList[0])
            tf.close()
            tf      = file('tmp.log','r')
            TmpFit  = P1.search(tf.read())
            if TmpFit:
                LocPos = 0
                while TmpFit:
                    LocPos += TmpFit.end()
                    tf.seek(LocPos)
                    TmpFit  = P1.search(tf.read())
                else:
                    tf.seek(LocPos)
                for i in range(4):
                    TmpList = tf.readline().split()
                    if TmpList[4].strip()=='YES':
                        pass
                    elif TmpList[4].strip()=='NO':
                        GeomConv    = False
                        break
                    else:
                        GeomConv    = False
                        break
                else:
                    GeomConv    = True
            else:
                GeomConv    = False

            if GeomConv:
                LocPos  = tf.tell()
                TmpFit  = P2.search(tf.read())
                if TmpFit:
                    LocPos  += TmpFit.end()
                    tf.seek(LocPos)
                    for i in range(4):
                        tf.readline()
                    CList   = []
                    for i in range(self.GauIO.NAtom):
                        TmpList = tf.readline().split()[3:]
                        for i in range(3):
                            try:
                                TmpList[i] = float(TmpList[i])
                            except:
                                TmpList[i] = 'NAN'
                        CList.append(TmpList)
                else:
                    CList   = []
                    for i in range(self.GauIO.NAtom):
                        CList.append(['NAN'] * 3)
                if self.IPrint>=2:
                    print_String(self.IOut,
                        'Geometry convergence is meeted for '+\
                        'the job of %s' % self.GauIO.JobName,1)
                FormList=['%12d%16.5f%16.5f%16.5f','%12s%16s%16s%16s']
                PrinList=[['IAn','X','Y','Z']]
                for i in range(self.GauIO.NAtom):
                    CList[i].insert(0,self.GauIO.IAn[i])
                    TmpList = CList[i][:]
                    PrinList.append(TmpList)
                print_List_free(self.IOut,PrinList,2,FormList)
            else:
                CList   = []
                for i in range(self.GauIO.NAtom):
                    CList.append(['NAN'] * 3)
                    CList[i].insert(0,self.GauIO.IAn[i])
                if self.IPrint>=2:
                    print_String(self.IOut,
                        'Geometry convergence fails for the job of %s'\
                        % self.GauIO.JobName,1)
            tf.close()
            remove('tmp.log')
            return (GeomConv,CList)

    def collect_CCSD(self):
        '''Collect CCSD energes from Log file'''
        from my_io      import print_String
        from my_io      import print_Error 
        from my_io      import print_List
        from re         import compile
        self.IOut.flush()
        self.rf.seek(0)
        TmpFile     = self.rf.read()
        NEngy       = TmpFile.count('E(CORR)=')
        LocPos      = 0
        if self.IPrint>=2:
            print_String(self.IOut,
                'There are %3d CCSD iterated energies in the log file'
                % NEngy,1)
        for i in range(NEngy-1):
            LocPos  = TmpFile.find('E(CORR)=',LocPos+1)
        LocPos      = TmpFile.find('E(CORR)=',LocPos+1)
        try:
            TmpEngy = float(TmpFile[LocPos+1:].split()[1])
            print_String(self.IOut,
                'The CCSD energy is %16.8f'
                % TmpEngy,1)
        except ValueError:
            print_String(self.IOut,
                'Error in collecting CCSD energy '+\
                '\"LogHandle.collect_EngyReal\"',2)
        return

class OptHandle:
    '''\
    Handle Geometry Optimization\
    '''
    def __init__(self,iout,IOClass,bugctrl=0):
        '''\
        Initialize variables belonged to OptHandle\
        '''
        from os        import getcwd
        from os        import getenv
        from os.path   import isfile
        from os.path   import exists
        from os        import mkdir
        from re        import compile

        from my_io import print_Error
        from my_io import print_String
        from my_io import print_List

        self.WorkDir    = getcwd().strip()                           # STRING, Working DIR 
        self.HomeDir    = getenv('HOME')                             # STRING, HOME DIR
        if getenv('IGOR_MODULES_PATH'):                                # STRING, private module DIR
            self.ModuDir=getenv('IGOR_MODULES_PATH')
        else:
            print_Error(self.IOut,
                'Error in getting grobal environment '+\
                '\"$IGOR_MODULES_PATH\" which is the direction to private modules')

        self.IOut       = iout
        self.IPrint     = bugctrl
        self.IOClass    = IOClass

        self.Opt        = False                                      # LOGIC for geom. opt. task
        self.Conv       = False                                      # LOGIC for opt convergency
        self.Hessian    = False                                      # LOGIC for freq calc. task
        self.MaxStep    = 30                                         # INTEGER, maximum step size
        self.NP		    = 1                                          # INTEGER, opt points
        self.OptType    = 0                                          # INTEGER :: 
                                                                     #  0 for Estimated Hessian;
                                                                     #  1 for "calcfc";
                                                                     #  2 for "calcall"

        self.OptionList = []                                         # LIST, options prepered
        self.Energy     = self.IOClass.EngyReal                      # REAL, Total energy
        self.ForcList   = self.IOClass.ForcList                      # LIST, Force in question
        self.HessList   = self.IOClass.HessList                      # LIST, Hessian in question
        for option in self.IOClass.OptionList:
            tmpOpt=option.lower().strip()
            if tmpOpt.find('opt')!=-1:
                self.Opt= True
                print_String(self.IOut,
                    'Geometry optimization turns on',1)
                p1	= compile('[(),]')
                for tmp1 in p1.split(tmpOpt):
                    if tmp1.find('maxstep')!=-1:
                        self.MaxStep	= int(tmp1.split('=')[1])
                        tmpStep		= float(self.MaxStep)*0.01
                        print_String(self.IOut,
                            'Maximum step size (%8.4f) in Opt.'
                            % tmpStep, 1)
                    if tmp1.find('calcfc')!=-1:
                        self.OptType=1
                        print_String(self.IOut,
                            'OptType: \"CalcFC\" turns on', 1)
                    elif tmp1.find('calcall')!=-1:
                        self.OptType=2
                        print_String(self.IOut,
                            'OptType: \"CalcAll\" turns on', 1)
            elif tmpOpt.find('freq')!=-1:
                self.Hessian=True
                print_String(self.IOut,
                    'Frequence calculation turns on', 1)
            elif tmpOpt=='force':
                pass
            else:
                self.OptionList.append(option)
       #self.IOClass.OptionList	= self.OptionList[:]                 # recopy Options into IOClass
        if self.IPrint >= 2:
            print_List(self.IOut,self.OptionList,3,
                'Filtering OptionList by "OptHandle" '+\
                'for geomerty optimization')
        if self.Opt:
            if not exists('%s/GeomOpt' % self.WorkDir):
                mkdir('%s/GeomOpt' % self.WorkDir)
            tmpf=file('%s/GeomOpt/geom' % self.WorkDir,'w')
            tmpf.write('%5i\n' % self.IOClass.NAtom)
            for i in self.IOClass.GeomList:
                tmpf.write('%s\n' %i)
            tmpf.close()
        return


    def __del__(self):
        return

    def gen_OptionList(self):
        '''Generate OptionList for different self.NP''' 
        self.IOClass.OptionList=self.OptionList[:]
        for option in self.OptionList:
            self.IOClass.OptionList.append(option)
        if (self.Conv and self.Hessian) \
          or (not self.Opt and self.Hessian) :                       # for freq calculation
            self.IOClass.OptionList.append('freq')
        elif self.Opt and not self.Conv and self.OptType==0:         # for default optimization
            self.IOClass.OptionList.append('force') 
        elif not self.Conv and self.OptType==1 and self.NP!=1:       # for "calcfc" at NP>=1
            self.IOClass.OptionList.append('force')
        elif not self.Conv and self.OptType==1 and self.NP==1:       # for "calcfc" at NP=0
            self.IOClass.OptionList.append('freq')
        elif not self.Conv and self.OptType==2:                      # for "calcall"
            self.IOClass.OptionList.append('freq')
        self.IOClass.OptionList.append('NoSymm')
        return
    def gen_rGOInp(self):
        '''Generate rGO interface'''
        from my_io import print_List
        tmpf		= file('%s/GeomOpt/head' %self.WorkDir,'w')
        tmpf.write('%3i\n' % self.NP)                                # Write self.NP
        tmpf.write('%3i\n' % self.OptType)                           # Write self.OptType
        tmpf.write('%3i\n' % self.MaxStep)                           # Write self.MaxStep
        tmpf.close()
        tmpf		= file('%s/GeomOpt/NP%i'
            %(self.WorkDir,self.NP),'w')
        tmpf.write('Energy%s=%16.8f  A.U.\n'
            %(' '*12,self.IOClass.EngyReal))
        print_List(tmpf, self.IOClass.ForcList, 5, 
            'Cartesian Gradient:')
        if self.IPrint>=2:
            print_List(self.IOut, self.IOClass.ForcList, 4,
                'Cartesian Gradient for rGO interface:'+\
                ' \'OptHandle.gen_rGOInp\'')
        if (self.OptType==1 and self.NP==1)\
         or self.OptType==2:
            print_List(tmpf, self.IOClass.HessList, 5,
                'Cartesian Force Constants:')
            if self.IPrint>=2:
                print_List(self.IOut, self.IOClass.HessList, 4,
                'Cartesian Force Constants for rGO interface:')
        tmpf.close()
        return
    def run_rGO(self):
        '''run rGO'''
        from os import chdir
        from os import system
        chdir('%s/GeomOpt' % self.WorkDir)
        system('%s/rGO/rGO' % self.ModuDir)
        chdir('%s' % self.WorkDir)
        self.NP += 1
        return
    def collect_rGOResult(self):
        '''Get Opt Information from the file of "OptInfo".\n\
 It is the interface with the rGO package\n'''
        from my_io import print_Error
        from my_io import print_List
        optf		= file('%s/GeomOpt/optinfo' %self.WorkDir,'r')   # Collect rGO info.
        TmpList		= optf.read().split('\n')
        if int(TmpList[0]) == 1:
            self.Conv	=True
        elif int(TmpList[0]) == 0:
            self.Conv	=False
        else:
            print_Error(self.IOut,'Error in reading OPT state\n')
        print_List(self.IOut,TmpList,2,'Geom. Opt. info.')
        optf.close()
        optf		= file('%s/GeomOpt/geom' % self.WorkDir,'r')     # Update molecular geometry 
        TmpList		= optf.readlines()
        self.IOClass.GeomList	= []
        for tmp in TmpList[1:]:
            self.IOClass.GeomList.append(tmp.strip())                # Update IOClass.GeomList
        optf.close()
        self.IOClass.update_CList()                                  # Update IOClass.CList
        if not self.Conv:                                            # Print update GeomList
            print_List(self.IOut, self.IOClass.GeomList, 2,
                'Update %3dth Geometry:' % self.NP)
        else:
            print_List(self.IOut, self.IOClass.GeomList, 2,
                'Final Geometry:')
        return 

class R5DFT:
    '''\
    Handel the scheme of R5DFT\
    '''
    IFLAG       = 'routine'                                          # Flag : routine or develop
    #List the available R5DFTs and corresponding parameters
    R5DFTList   = [\
 'Name','Base','Ex_HF','Ex_LDA','Ex_dGGA','Ec_LDA','Ec_dGGA','Ec_MP2'\
              ]
    R5DFTDict   = {\
      'XYG3': [ 'B3LYP',0.8033,0.1967,0.2107,0.6789,0.6789,0.3211], \
     'UXYG3': ['UB3LYP',0.8033,0.1967,0.2107,0.6789,0.6789,0.3211], \
  'XYG3_DFT': [ 'B3LYP',0.8033,0.1967,0.2107,0.6789,0.6789,0.0000], \
 'UXYG3_DFT': [ 'B3LYP',0.8033,0.1967,0.2107,0.6789,0.6789,0.0000], \
   'XYG3_FC': [ 'B3LYP',0.8033,0.1967,0.2107,0.6789,0.6789,0.3211], \
  'UXYG3_FC': ['UB3LYP',0.8033,0.1967,0.2107,0.6789,0.6789,0.3211]\
              }
    MP2List	= ['Name','MP2_aa','MP2_ab','MP2_bb']
    MP2Dict	= {'XYG3'     :[1.000,1.000,1.000],
               'UXYG3'    :[1.000,1.000,1.000],
               'XYG3_DFT' :[0.000,0.000,0.000],
              'UXYG3_DFT' :[0.000,0.000,0.000],
               'XYG3_FC'  :[1.000,1.000,1.000],
              'UXYG3_FC'  :[1.000,1.000,1.000],
               'XYG3-SOS' :[1.000,1.000,1.000]}

    if IFLAG    == 'routine':
        LDADict = { 'XYG3':'402 0 0.8033 0.1967 0.2107 0.6789 0.6789',
                   'UXYG3':'402 0 0.8033 0.1967 0.2107 0.6789 0.6789',
                'XYG3_DFT':'402 0 0.8033 0.1967 0.2107 0.6789 0.6789',
               'UXYG3_DFT':'402 0 0.8033 0.1967 0.2107 0.6789 0.6789',
                 'XYG3_FC':'402 0 0.8033 0.1967 0.2107 0.6789 0.6789',
                'UXYG3_FC':'402 0 0.8033 0.1967 0.2107 0.6789 0.6789',
                     }
    elif IFLAG  == 'develop':
        LDADict = { 'XYG3':'205',
                   'UXYG3':'205',
                 'XYG3_FC':'205',
                'UXYG3_FC':'205'}
                                                                     # For SP calc.
    SP_ExOvLay  = {  'XYG3':['8/7=1,10=90/1;','9/16=-3/6;','6//8;'],
                    'UXYG3':['8/7=1,10=90/1;','9/16=-3/6;','6//8;'],
                 'XYG3_DFT':['6//8;'],
                'UXYG3_DFT':['6//8;'],
                  'XYG3_FC':['8/7=1,10=4/1;','9/16=-3/6;','6//8;'],
                 'UXYG3_FC':['8/7=1,10=4/1;','9/16=-3/6;','6//8;']\
                  }
    SP_OptList  = ['IOP(5/33=1)','NoSymm']


                                                                     # For Geom. Opt.
    ExOvLay01   = {'XYG3':
                      {0:['6//8;'],
                       1:['6//8;']
                       } 
                   }
    ExOvLay02   = {'XYG3':
                      {0:['7/29=1,30=1/1,2,3,16;',
                          '99/5=1/99;'],
                       1:['8/6=4,10=90,11=11/1;',
                          '11/6=1,8=1,9=11,15=111,16=1,31=1/1,2,10;',
                          '10/6=1,31=1/2;',
                          '7/8=1,10=1,25=1,30=1/1,2,3,16;',
                          '99/5=1,9=1/99;'] 
                       }
                   }
    ExOvLay03   = {'XYG3':
                      {0:['8/6=4,7=1,10=90/1;',
                          '9/15=2,16=-1/6;',
                          '10/5=1,31=1/2;',
                          '7/12=2,29=1,30=1/1,2,3,16;',
                          '99/5=1/99;'],
                       1:['8/6=3,7=1,8=1,10=90,19=11,30=-1/1;',
                          '9/15=3,16=-3/6;',
                          '11/6=1,8=1,15=11,17=12,24=-1,27=1,28=-2,29=300,31=1,32=6,42=3/1,2,10;',
                          '10/6=2,21=1,31=1/2;',
                          '8/6=4,8=1,10=90,19=11,30=-1/11,4;',
                          '10/5=1,20=4,31=1/2;',
                          '11/12=2,14=11,16=1,17=2,28=-2,31=1,42=3/2,10,12;',
                          '7/8=1,10=1,12=2,25=1,30=1,44=2/1,2,3,16;',
                          '99/5=1,9=1/99;']
                       }
                   }
    ExOvLay04   = {'XYG3':
                      {0:['7/29=1,30=1/1,2,3,16;',
                          '99/5=1/99;'],
                       1:['8/6=4,10=90,11=11/1;',
                          '11/6=1,8=1,9=11,15=111,16=1,31=1/1,2,10;',
                          '10/6=1,31=1/2;',
                          '7/8=1,10=1,25=1,30=1/1,2,3,16;',
                          '99/5=1,9=1/99;'] 
                       }
                   }

    OptList01   = {'XYG3':
                      {0:['B3LYP','SCF=Tight',
                          'IOP(5/33=1,6/109=1,6/110=1)',
                          'force','NoSymm','ExtraOverlay'],
                       1:['B3LYP','SCF=Tight',
                          'IOP(5/33=1,6/109=1,6/110=1)',
                          'freq','NoSymm','ExtraOverlay']
                       }
                   }
    OptList02   = {'XYG3':
                      {0:['Guess=(Read,Only)','ExtraOverlay',
                          'IOP(5/33=1,6/105=1,6/110=1)',
                          'IOP(3/74=402,3/76=0196708033)',
                          'IOP(3/77=1071210000,3/78=0678906789)',
                          'NoSymm'],
                       1:['Guess=(Read,Only)','ExtraOverlay',
                          'IOP(5/33=1,6/105=1,6/109=1,6/110=1)',
                          'IOP(3/74=402,3/76=0196708033)',
                          'IOP(3/77=1071210000,3/78=0678906789)',
                          'NoSymm']
                        }
                   }
    OptList03   = {'XYG3':
                      {0:['HF','Guess=(Read,Only)','ExtraOverlay',
                          'IOP(5/33=1,6/105=1,6/109=1,6/110=1)',
                          'NoSymm'],
                       1:['Guess=(Read,Only)','ExtraOverlay',
                          'IOP(5/33=1,6/105=1,6/109=1,6/110=1)',
                          'NoSymm']
                       }
                   }
    OptList04   = {'XYG3':
                      {0:['HF','Guess=(Read,Only)','ExtraOverlay',
                          'IOP(5/33=1,6/105=1,6/109=1,6/110=1)',
                          'NoSymm'],
                       1:['Guess=(Read,Only)','ExtraOverlay',
                          'IOP(5/33=1,6/105=1,6/109=1,6/110=1)',
                          'NoSymm']
                       }
                   }

    def __init__(self, IOut, GauIO, OptClass, bugctrl=0):
        '''\
        Open the current filename, and initialize some variable belonged to current object\
        ''' 
        from re     import compile
        from os.path    import isfile

        import gaussian_manage as gaum
        from my_io	import print_Error
        from my_io	import print_String
        from my_io	import print_List

        self.GauIO      = GauIO
        self.IOut       = IOut
        self.IPrint     = bugctrl
        self.OptClass   = OptClass

        self.DFTPara    = []                                         # DFT Para. of selected R5DFT
        self.MP2Para    = []                                         # MP2 Para. of selected R5DFT

        self.TurnOn     = False                                      # Turn on R5DFT scheme or Not
        for option in GauIO.OptionList:
            for key in sorted(R5DFT.R5DFTDict.keys()):
                tmpOption=option.lower().split('/')
                if tmpOption[0]==key.lower():
                    if len(tmpOption) == 2:
                        TmpBasis  = tmpOption[1]
                        GauIO.OptionList.append(TmpBasis)
                        GauIO.OptionList.remove(option)
                    elif len(tmpOption) == 1:
                        GauIO.OptionList.remove(option)
                    else:
                        print_Error(self.IOut,
                        'Error happens in R5DFT method determine')
                    self.TurnOn = True
                    self.R5DFT  = key
                    self.DFTPara= R5DFT.R5DFTDict[key][:]
                    self.MP2Para= R5DFT.MP2Dict[key][:]
                    print_String(self.IOut,
                        '"%s" is choosen for the question'
                        % self.R5DFT,1)
                    if self.IPrint>=2:
                        print_List(self.IOut,
                            self.DFTPara,3,
                            '%s\'s DFTPara(%d) :'
                            % (self.R5DFT,len(self.DFTPara)))
                        print_List(self.IOut,
                            self.MP2Para,3,
                            '%s\'s MP2Para(%d) :'
                            % (self.R5DFT,len(self.MP2Para)))
                    break
        if self.TurnOn:
            if not self.OptClass.Opt:                                # For sp calc.
                GauIO.OptionList.append(self.DFTPara[0])
                for iterm in R5DFT.SP_OptList:
                    GauIO.OptionList.append(iterm)
                GauIO.OptionList.append('ExtraOverlay')
                GauIO.MoreOptionDict['extraoverlay']	= 1
                for key in sorted(R5DFT.SP_ExOvLay.keys()):
                    if self.R5DFT.lower()==key.lower():
                        tmpExOvLay = R5DFT.SP_ExOvLay[key][:]
                        # Patch for "9/16=-1":
                        for opkey in GauIO.OptionList:
                            if opkey.find('9/16=-1')!=-1:
                                for eokey in tmpExOvLay:
                                    if eokey.find('9/16=-3/6;')!=-1:
                                        eoind = tmpExOvLay.index(eokey)
                                        tmpExOvLay[eoind]='9/16=-1/6;'
                                break
                        # Patch end
                        #GauIO.SP_ExOvLay.pop(opkey)
                        GauIO.ExOvList.extend(tmpExOvLay)
                # Modify for "gen" basis set input (V1.5)
                if len(GauIO.RestList)==0:
                    GauIO.RestList.append('%s' 
                        % R5DFT.LDADict[self.R5DFT])
                else:
                    # Fix for "gen" basis set file input (V1.6)
                    p1      = compile('@')
                    if p1.match(GauIO.RestList[-1]):
                        if self.IPrint >= 2:
                            print_String(self.IOut,
                                'Now check for basis set file',1)
                        if isfile(GauIO.RestList[-1][1:]):
                            tmpf = open(GauIO.RestList[-1][1:],'r')
                            tmpList = tmpf.readlines()
                            if tmpList[-1].strip()=='':
                                GauIO.RestList.append('%s' 
                                    % R5DFT.LDADict[self.R5DFT])
                            else:
                                GauIO.RestList.append('\n%s' 
                                    % R5DFT.LDADict[self.R5DFT])
                            tmpf.close()
                        else:
                            print_Error(self.IOut,'The basis set file %s'
                                    % GauIO.RestList[-1][1:] + ' is not exist')
                    else:
                        GauIO.RestList.append('\n%s' 
                            % R5DFT.LDADict[self.R5DFT])
                return
            else:                                                    # For geom. opt. calc.
                GauIO.MoreOptionDict['extraoverlay']	= 1
                self.One        =\
                        gaum.GauIO(self.IOut,None,self.IPrint)       #  self.One for B3LYP SCF
                self.One.copy_DataIO(GauIO)                          #   and EngyReal calc.
                self.One.JobName= 'One-%s' % GauIO.JobName
                self.One.ChkName= 'One-%s' % GauIO.ChkName
                self.One.RestList.append('%s' 
                    % R5DFT.LDADict[self.R5DFT])

                self.Two        =\
                        gaum.GauIO(self.IOut,None,self.IPrint)       #  self.Two for truncated DFT
                self.Two.copy_DataIO(GauIO)
                self.Two.JobName= 'Two-%s' % GauIO.JobName
                self.Two.ChkName= 'Two-%s' % GauIO.ChkName
                
                self.MP2        =\
                        gaum.GauIO(self.IOut,None,self.IPrint)       #  self.MP2 for Ec_MP2 term
                self.MP2.copy_DataIO(GauIO)
                self.MP2.JobName= 'MP2-%s' % GauIO.JobName
                self.MP2.ChkName= 'MP2-%s' % GauIO.ChkName

                self.HF         =\
                        gaum.GauIO(self.IOut,None,self.IPrint)       #  self.MP2 for Ec_MP2 term
                self.HF.copy_DataIO(GauIO)
                self.HF.JobName = 'HF-%s' % GauIO.JobName
                self.HF.ChkName = 'HF-%s' % GauIO.ChkName
                
                for i in [self.One,self.Two,self.MP2,self.HF]:
                    for option in i.MachineList:                     # Initialize MachineLists
                        if option.lower().find('%chk')!=-1:
                            i.MachineList.append('%chk'+'=%s.chk'
                                % i.ChkName) 
                            i.MachineList.remove(option)
                            break
                    else:
                        i.MachineList.append('%chk=%s.chk'
                            %i.ChkName)
                    i.MachineList.append(' '.join([\
                        '%subst l601','L601/%s/GauIO/My_L601'\
                        % i.ModuDir]))
                    if self.IPrint>=2:                               # Debugging
                        print_List(self.IOut,i.MachineList,3,
                            'MachineList for %s of %s' 
                            % (i.JobName,self.R5DFT))
        return
    def __del__(self):
        '''\
        To del several class variables\
        '''
        if self.OptClass.Opt and self.TurnOn:
            del self.One
            del self.Two
            del self.MP2
            del self.HF
        return
    def collect_EngyReal(self,EngyPos=None):
        '''\
        Calculate R5DFT energy\
        '''
        import gaussian_manage as gaum
        from my_io	import print_String
        from my_io	import my_plus
        from my_io	import my_substract
        from my_io	import my_product
        from my_io	import my_divide

        if EngyPos!=None: self.IOut.seek(EngyPos)

        if not self.OptClass.Opt:                                    # For SG Calc::GauIO.EngyReal
            Result = gaum.LogHandle(self.IOut,self.GauIO,self.IPrint)
            Result.collect_DFT(self.DFTPara[0],R5DFT.IFLAG)
            if self.R5DFT=='XYG3_DFT' or self.R5DFT=='UXYG3_DFT':
                Ec_MP2 = 0.0
            elif self.R5DFT!='XYG3_DFT' or self.R5DFT!='UXYG3_DFT':
                Result.collect_MP2()
                Ec_MP2 = 0.0
                for i in range(3):
                    Ec_MP2  = my_plus(Ec_MP2,	
                        my_product(Result.Ec_MP2[i],self.MP2Para[i]))
            if R5DFT.IFLAG=='routine':
                if self.IPrint >=2:
                    try:
                        print_String(self.IOut,
                            'DFT parts in %8s is %16.8f A.U.'
                            % (self.R5DFT,Result.EngyNoMP2),2)
                    except TypeError:
                        print_String(self.IOut,
                            'DFT parts in %8s is %16s A.U.'
                            % (self.R5DFT,Result.EngyNoMP2),2)
                self.GauIO.EngyReal	= my_plus(Result.EngyNoMP2,
                    my_product(Ec_MP2, self.DFTPara[6]))
            elif R5DFT.IFLAG=='develop':
                self.GauIO.EngyReal	= Result.EngyNoXC
                self.GauIO.EngyReal = my_plus(self.GauIO.EngyReal,
                    my_product(Result.Ex_HF,  self.DFTPara[1]))
                self.GauIO.EngyReal = my_plus(self.GauIO.EngyReal,
                    my_product(Result.Ex_LDA, self.DFTPara[2]))
                self.GauIO.EngyReal = my_plus(self.GauIO.EngyReal,
                    my_product(Result.Ex_dGGA,self.DFTPara[3]))
                self.GauIO.EngyReal = my_plus(self.GauIO.EngyReal,
                    my_product(Result.Ec_LDA, self.DFTPara[4]))
                self.GauIO.EngyReal = my_plus(self.GauIO.EngyReal,
                    my_product(Result.Ec_dGGA,self.DFTPara[5]))
                self.GauIO.EngyReal = my_plus(self.GauIO.EngyReal,
                    my_product(Ec_MP2,        self.DFTPara[6]))
            try:
                print_String(self.IOut,
                    'E(%s)%s= %16.8f A.U.    E(%s)%s= %16.8f A.U.'  
                    %(self.DFTPara[0],' '*(9-len(self.DFTPara[0])),\
                    Result.EngyReal,\
                    self.R5DFT,' '*(9-len(self.R5DFT)),\
                    self.GauIO.EngyReal),2)
            except:
                print_String(self.IOut,
                    'E(%s)%s= %16s A.U.      E(%s)%s= %16s A.U.'  
                    %(self.DFTPara[0],' '*(9-len(self.DFTPara[0])),\
                    Result.EngyReal,\
                    self.R5DFT,' '*(9-len(self.R5DFT)),\
                    self.GauIO.EngyReal),2)
            del Result
            return self.GauIO.EngyReal
        else:                                                        # For GeomOpt:: One.EngyReal
            Result1 = gaum.LogHandle(self.IOut,self.One,self.IPrint)
            Result1.collect_DFT(self.DFTPara[0])

            Result3 = gaum.LogHandle(self.IOut,self.MP2,self.IPrint)
            Result3.collect_MP2()
            Ec_MP2 = 0.0
            for i in range(3):
                Ec_MP2	= my_plus(Ec_MP2,
                    my_product(Result3.Ec_MP2[i],self.MP2Para[i]))
            self.GauIO.EngyReal = my_product(Result1.EngyNoMP2,
                my_product(Ec_MP2, self.DFTPara[6]))
            try:
                print_String(self.IOut,
                    'E(%s)%s= %16.8f A.U.' 
                    % (self.R5DFT,' '*(9-len(self.R5DFT)), 
                       self.GauIO.EngyReal),2)
            except:
                print_String(self.IOut,
                    'E(%s)%s= %16s A.U.' 
                    % (self.R5DFT,' '*(9-len(self.R5DFT)), 
                       self.GauIO.EngyReal),2)
            del Result1
            del Result3
            return self.GauIO.EngyReal
    def collect_OptInfo(self):
        '''\
        Obtain geom. opt. info. (ForcList and HessList) from chkfile and update them into self.GauIO which is avariable of GauIO class\
        '''
        import gaussian_manage as gaum
        from my_io      import print_Error
        from my_io      import print_String
        from my_io      import print_List
        from my_io	    import my_plus
        from my_io	    import my_substract
        from my_io	    import my_product
        from my_io	    import my_divide
        index       = 2                                              # 2 is unmeaning index
        if (self.OptClass.Conv and self.OptClass.Hessian) \
          or (not self.OptClass.Opt and self.OptClass.Hessian) :     # for freq calculation
            index	= 1
        elif not self.OptClass.Conv and self.OptClass.OptType==0:    # for default optimization
            index	= 0
        elif not self.OptClass.Conv and self.OptClass.OptType==1\
            and self.OptClass.NP!=1:                                 # for "calcfc" at NP>=1
            index	= 0
        elif not self.OptClass.Conv and self.OptClass.OptType==1\
            and self.OptClass.NP==1:                                 # for "calcfc" at NP=0
            index	= 1
        elif not self.OptClass.Conv and self.OptClass.OptType==2:    # for "calcall"
            index	= 1

        if index==2:                                                 # Unmeaning option
            print_Error(self.IOut,
                'Error in OptClass.OptType determination'+\
                ' \'R5DFT.collect_OptInfo\'')
        elif index==0:                                               # Just ForcList is needed
            Result1 = gaum.ChkHandle(self.IOut,self.One,self.IPrint)
            Result2 = gaum.ChkHandle(self.IOut,self.Two,self.IPrint)
            Result3 = gaum.ChkHandle(self.IOut,self.MP2,self.IPrint)
            Result4 = gaum.ChkHandle(self.IOut,self.HF,self.IPrint)
            Result1.collect_ForcList()
            Result2.collect_ForcList()
            Result3.collect_ForcList()
            Result4.collect_ForcList()
            if len(Result1.ForcList)!=len(Result2.ForcList) or\
                len(Result1.ForcList)!=len(Result3.ForcList) or\
                len(Result1.ForcList)!=len(Result4.ForcList):
                    print_Error(self.IOut,
                        'Unconsistency of ForceList dimension'+\
                        ' for One, Two, MP2 and HF'+\
                        ' \'R5DFT.collect_OptInfo\'')
            self.GauIO.ForcList    = []
            for i in range(len(Result1.ForcList)):
                self.GauIO.ForcList.append(Result2.ForcList[i] + \
                    (Result3.ForcList[i]-Result4.ForcList[i]) * \
                    self.DFTPara[6])
            if self.IPrint>=2:
                print_List(self.IOut,Result1.ForcList,4,
                    '%s Cartesian Gradient:' % self.DFTPara[0])
            if self.IPrint>=1:
                print_List(self.IOut,self.GauIO.ForcList,4,
                    '%s Cartesian Gradient:' % self.R5DFT)

        elif index==1:                                               # HessList is also required
            Result1 = gaum.ChkHandle(self.IOut,self.One,self.IPrint)
            Result2 = gaum.ChkHandle(self.IOut,self.Two,self.IPrint)
            Result3 = gaum.ChkHandle(self.IOut,self.MP2,self.IPrint)
            Result4 = gaum.ChkHandle(self.IOut,self.HF,self.IPrint)

            Result1.collect_ForcList()
            Result2.collect_ForcList()
            Result3.collect_ForcList()
            Result4.collect_ForcList()
            if len(Result1.ForcList)!=len(Result2.ForcList) or\
                len(Result1.ForcList)!=len(Result3.ForcList) or\
                len(Result1.ForcList)!=len(Result4.ForcList):
                    print_Error(self.IOut,
                        'Unconsistency of ForcList dimension'+\
                        ' in One, Two, MP2 and HF'+\
                        ' \'R5DFT.collect_OptInfo\'')
            self.GauIO.ForcList    = []
            for i in range(len(Result1.ForcList)):
                self.GauIO.ForcList.append(Result2.ForcList[i] + \
                    (Result3.ForcList[i]-Result4.ForcList[i]) * \
                    self.DFTPara[6])
            if self.IPrint>=2:
                print_List(self.IOut,Result1.ForcList,4,
                    '%s Cartesian Gradient (%s):'
                    % (self.DFTPara[0],len(Result1.ForcList)))
            if self.IPrint>=1:
                print_List(self.IOut,self.GauIO.ForcList,4,
                    '%s Cartesian Gradient (%s):'
                    % (self.R5DFT,len(self.GauIO.ForcList)))

            Result1.collect_HessList()
            Result2.collect_HessList()
            Result3.collect_HessList()
            Result4.collect_HessList()
            if len(Result1.HessList)!=len(Result2.HessList) or\
                len(Result1.HessList)!=len(Result3.HessList) or\
                len(Result1.HessList)!=len(Result4.HessList):
                    print_Error(self.IOut,
                        'Unconsistency of HessList dimension'+\
                        ' in One, Two, MP2 and HF'+\
                        ' \'R5DFT.collect_OptInfo\'')
            self.GauIO.HessList    = []
            for i in range(len(Result1.HessList)):
                self.GauIO.HessList.append(Result2.HessList[i] + \
                    (Result3.HessList[i]-Result4.HessList[i]) * \
                    self.DFTPara[6])
            if self.IPrint>=2:
                print_List(self.IOut,Result1.HessList,4,
                    '%s Cartesian Force Constants (%s):'
                    % (self.DFTPara[0],len(Result1.HessList)))
            if self.IPrint>=1:
                print_List(self.IOut,self.GauIO.HessList,4,
                    '%s Cartesian Force Constants (%s):'
                    % (self.R5DFT,len(self.GauIO.HessList)))
        del Result1
        del Result2
        del Result3
        del Result4
        return

    def gen_OptionList(self):
        '''\
        Generate OptionList for different self.NP\
        ''' 
        from my_io      import print_Error
        if not self.OptClass.Opt:
            return
        index       = 2                                              # invalid option
        if (self.OptClass.Conv and self.OptClass.Hessian) \
          or (not self.OptClass.Opt and self.OptClass.Hessian) :     # for freq calculation
            index	= 1
        elif not self.OptClass.Conv and self.OptClass.OptType==0:    # for default optimization
            index	= 0
        elif not self.OptClass.Conv and self.OptClass.OptType==1\
            and self.OptClass.NP!=1:                                 # for "calcfc" at NP>=1
            index	= 0
        elif not self.OptClass.Conv and self.OptClass.OptType==1\
            and self.OptClass.NP==1:                                 # for "calcfc" at NP=0
            index	= 1
        elif not self.OptClass.Conv and self.OptClass.OptType==2:    # for "calcall"
            index	= 1

        if index==2:                                                 # quit for invalid option
            print_Error(self.IOut,
                'Error in OptClass.OptType determination'+\
                ' \'R5DFT.gen_OptionList\'')
        self.One.OptionList = self.GauIO.OptionList[:]               # Prepare self.One
        self.One.OptionList.extend(\
            R5DFT.OptList01[self.R5DFT][index])
        self.One.ExOvList   = R5DFT.ExOvLay01[self.R5DFT][index][:]

        self.Two.OptionList = self.GauIO.OptionList[:]               # Prepare self.Two
        self.Two.OptionList.extend(\
            R5DFT.OptList02[self.R5DFT][index])
        self.Two.ExOvList   = R5DFT.ExOvLay02[self.R5DFT][index][:]

        self.MP2.OptionList = self.GauIO.OptionList[:]               # Prepare self.MP2
        self.MP2.OptionList.extend(\
            R5DFT.OptList03[self.R5DFT][index])
        self.MP2.ExOvList   = R5DFT.ExOvLay03[self.R5DFT][index][:]

        self.HF.OptionList  = self.GauIO.OptionList[:]               # Prepare self.HF
        self.HF.OptionList.extend(\
            R5DFT.OptList04[self.R5DFT][index])
        self.HF.ExOvList    = R5DFT.ExOvLay04[self.R5DFT][index][:]

        return
    
    def filter_Log(self,cons):
        '''filter log information for routine use'''
        import re
        p6 = re.compile(r'(?P<cons1>[^$]*)'                  # Input
                r'\sAdditional\soverlay\scards:\n\s*-*\n\s*8/7=1,10=[0-9]{1,2}/1;\s9/16=-[0-9]/6;\s6//8;\n\s*-*\n'                                                          # seperate 1
                r'(?P<cons2>[^$]*)'                          # SCF+MP2
                r'\s\(Enter\s[^\n]*l608.exe\)\n'             #           # seperate 2
                r'(?P<cons3>[^$]*)'                          # Detail DFT portions
                r'\sLeave\sLink\s*608\sat\s[a-z]{1,3}\s[a-z]{1,3}\s*[0-9]{1,2}\s*[0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2}\s[0-9]{1,4},sMaxMem=\s*[0-9]*\scpu:\s*[0-9]*.[0-9]\n'     # seperate 3
                r'(?P<cons4>[^$]*$)',                        # End
                re.VERBOSE|re.IGNORECASE)

        p5 = re.compile(r'(?P<cons1>[^$]*)'                  # Input
                r'\sAdditional\soverlay\scards:\n\s*-*\n\s*8/7=1,10=[0-9]{1,2}/1;\s9/16=-[0-9]/6;\s6//8;\n\s*-*\n'                                                          # seperate 1
                r'(?P<cons2>[^$]*)'                          # SCF+MP2
                r'\s\(Enter\s[^\n]*l608.exe\)\n'             #           # seperate 2
                r'(?P<cons3>[^$]*$)',                        # Detail DFT portions
                re.VERBOSE|re.IGNORECASE)

        p4 = re.compile(r'(?P<cons2>[^$]*)'                  # SCF+MP2
                r'\s\(Enter\s[^\n]*l608.exe\)\n'             #           # seperate 2
                r'(?P<cons3>[^$]*)'                          # Detail DFT portions
                r'\sLeave\sLink\s*608\sat\s[a-z]{1,3}\s[a-z]{1,3}\s*[0-9]{1,2}\s*[0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2}\s[0-9]{1,4},sMaxMem=\s*[0-9]*\scpu:\s*[0-9]*.[0-9]\n'     # seperate 3
                r'(?P<cons4>[^$]*$)',                        # End
                re.VERBOSE|re.IGNORECASE)

        p3 = re.compile(r'(?P<cons1>[^$]*)'                  # Input
                r'\sAdditional\soverlay\scards:\n\s*-*\n\s*8/7=1,10=[0-9]{1,2}/1;\s9/16=-[0-9]/6;\s6//8;\n\s*-*\n'                                                          # seperate 1
                r'(?P<cons2>[^$]*$)',                        # SCF+MP2
                re.VERBOSE|re.IGNORECASE)

        p2 = re.compile(r'(?P<cons2>[^$]*)'                  # SCF+MP2
                r'\s\(Enter\s[^\n]*l608.exe\)\n'             #           # seperate 2
                r'(?P<cons3>[^$]*$)',                        # Detail DFT portions
                re.VERBOSE|re.IGNORECASE)

        p1 = re.compile(r'(?P<cons3>[^$]*)'                  # Detail DFT portions
                r'\sLeave\sLink\s*608\sat\s[a-z]{1,3}\s[a-z]{1,3}\s*[0-9]{1,2}\s*[0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2}\s[0-9]{1,4},sMaxMem=\s*[0-9]*\scpu:\s*[0-9]*.[0-9]\n'     # seperate 3
                r'(?P<cons4>[^$]*$)',                        # End
                re.VERBOSE|re.IGNORECASE)

        if p1.match(cons):                                           # End (- "cons3")
            tmpGroup    = p1.match(cons)
            cons        = tmpGroup.group('cons4')
        elif p2.match(cons):                                         # (SCF+MP2) (- "cons3")
            tmpGroup    = p2.match(cons)
            cons        = tmpGroup.group('cons2')
        elif p3.match(cons):                                         # Input+(SCF+MP2)
            tmpGroup    = p3.match(cons)
            cons        =\
                    tmpGroup.group('cons1') + tmpGroup.group('cons2')
        elif p4.match(cons):                                         # (SCF+MP2)+End (- "cons3")
            tmpGroup    = p4.match(cons)
            cons        = \
                    tmpGroup.group('cons2') + tmpGroup.group('cons4')
        elif p5.match(cons):                                         # Input+(SCF+MP2) (- "cons3")
            tmpGroup    = p5.match(cons)
            cons        =\
                    tmpGroup.group('cons1') + tmpGroup.group('cons2')
        elif p6.match(cons):                                         # Input+(SCF+MP2)+End
            tmpGroup    = p6.match(cons)
            cons        = tmpGroup.group('cons1') + \
                    tmpGroup.group('cons2') + tmpGroup.group('cons4')
        return cons

    def cut_Log(self,pos,currdir):
        '''get log information in synchronism,\n
        return current end position'''
        from my_io  import print_String
        try:
            tf     = file('%s/Job_%s.log' 
                    %(currdir.value,self.GauIO.JobName), 'r')
            tf.seek(pos.value)
            tmpString   = tf.read()
            if pos.value != tf.tell():
                if R5DFT.IFLAG=='routine':
                    try:
                        tmpString   = self.filter_Log(tmpString)
                        self.IOut.write(tmpString)
                        self.IOut.flush()
                    except:
                        print('Error happens in cut_Log()')
                pos.value   = tf.tell()
            else:
                pass
            tf.close()
        except:
            print('Error happens in cut_Log() to open %s/Job_%s.log' \
                    % (currdir.value, self.GauIO.JobName))
        return

    def run_Job(self,sync=True):
        '''\
        Run R5DFT job in Gaussian package\
        '''
        from os 	import remove
        from multiprocessing    import Process, Manager
        from time               import sleep                         # sync log file by threads
        if sync==True:
            if not self.OptClass.Opt:
                self.GauIO.form_Inp()
                Pos     = Manager().Value('i',0)
                CurrDir = Manager().Value('c','.script')
                MainJob = Process(target = self.GauIO.run_GauJob,
                        args=(1,CurrDir))
                MainJob.start()
                while MainJob.is_alive():
                    sleep(12)
                    SyncJob = Process(target = self.cut_Log,
                        args=(Pos,CurrDir))
                    SyncJob.start()
                    SyncJob.join()
                    print('sync log during G03 procedure')
                else:
                    sleep(12)
                    CurrDir.value   = './'
                    SyncJob = Process(target = self.cut_Log,
                        args=(Pos,CurrDir))
                    SyncJob.start()
                    SyncJob.join()
                    print('sync log after G03 procedure')
            else:
                pass
                #self.One.form_Inp()
                #self.One.run_GauJob()
                #system('cp %s.chk %s.chk'
                #    % (self.One.ChkName, self.Two.ChkName))
                #self.Two.form_Inp()
                #self.Two.run_GauJob(iop=1)
                #system('cp %s.chk %s.chk'
                #    % (self.One.ChkName, self.MP2.ChkName))
                #self.MP2.form_Inp()
                #self.MP2.run_GauJob(iop=1)
                #system('cp %s.chk %s.chk'
                #    % (self.One.ChkName, self.HF.ChkName))
                #self.HF.form_Inp()
                #self.HF.run_GauJob(iop=1)
        else:                                                        # Do not sync log file
            if not self.OptClass.Opt:
                self.GauIO.form_Inp()
                self.GauIO.run_GauJob(1)
            else:
                pass
        return


class DFTD:
    '''\
    This class handles DFT+D calculation cooperating with Gaussian package and "dft_d" module.\n\
    NOTE :: "DFTD" should be loaded after modules of  "GauIO" and "OptHandle"\n\
    Scale parameter for six-order terms "s6" following are originated from\n\
        1) Grimme... Vol.27 , 1787, J. Comp. Chem.\n\
        2) Martin... Vol.113, 8434, J. Phys. Chem. A\n\
    \n\
    disp_g  is the pure dispersion of Grimme\n\
    disp_6  is the unscaled Grimme's dispersion\n\
    disp_12 is the unscaled tweleve-order term extended by Grimme's s6 and LG form\n\
    disp_xy\n\
    disp\
    '''
    GrimDict    = {\
  'b3lyp+d' : [1.05 ,  'b3lyp'] ,      'b971+d' : [0.65 ,   'b971'] , 
   'b972+d' : [1.05 ,   'b972'] ,       'bmk+d' : [0.65 ,    'bmk'] , 
   'blyp+d' : [1.20 ,   'blyp'] ,     
  'm062x+d' : [0.06 ,  'm062x'] ,     
    'pbe+d' : [0.75 , 'pbepbe'] ,    'pbepbe+d' : [0.75 , 'pbepbe'] , 
   'pbe0+d' : [0.70 ,   'pbe0'] ,   
   'tpss+d' : [1.00 ,   'tpss'] ,   
  'x3lyp+d' : [0.85 ,  'x3lyp']\
                }
    DispDict    = {
   'disp_g' : [1.00 , 'disp_g'] , 'dispersion_g': [1.00,  'disp_g'] ,
   'disp_6' : [1.00 , 'disp_6'] , 'dispersion_6': [1.00,  'disp_6'] ,
  'disp_12' : [1.00 ,'disp_12'] ,'dispersion_12': [1.00, 'disp_12'] ,
 'disp_12s' : [1.00 ,'disp_12s'] ,'dispersion_12s': [1.00, 'disp_12s'] ,
     'disp' : [1.00 ,   'disp'] ,   'dispersion': [1.00,    'disp']\
                  }

    def __init__(self, iout, GauIO, OptClass, bugctrl=0,\
        c6para=None, c12para=None, r0para=None, dpara=None):
        '''\
        Initialize parameters\
        '''
        from my_io import print_Error
        from my_io import print_String
        from dft_d import DispGrim
        self.IOut       = iout                                       # Set the logout file string
        self.GauIO      = GauIO                                      # Loading GauIO class
        self.OptClass   = OptClass                                   # Loading OptHandle class
        self.DispClass  = None                                       # DispClass
 #
        self.IPrint     = bugctrl                                    # INTEGER, control debugging
        self.AtLabel    = self.GauIO.AtLabel                         # List of AtLabel
        self.CList      = self.GauIO.CList                           # List of Geom. Info.
        self.IAn        = self.GauIO.IAn                             # List of IAn
        self.Method     = ''                                         # STRING, name of DFT+D
        self.SixPara    = 1.0                                        # REAL, Parameter of disp.
 #
        self.EngyReal   = 0.0                                        # REAL, dispersion energy
        self.ForcList   = []                                         # List, dispersion force
        self.HessList   = []                                         # List, dispersion hessian
        self.TurnOn     = False                                      # LOGIC, turn on or off DFT+D
        self.PureDisp   = False                                      # LOGIC, pure disp. calc.
 #
        for option in self.GauIO.OptionList:                         # Filter DFT+D method 
            for key in sorted(DFTD.GrimDict.keys()):
                TmpList=option.strip().split('/')
                if TmpList[0].lower()==key:
                    self.TurnOn   = True
                    self.Method   = key
                    self.SixPara=DFTD.GrimDict[key][0]
                    if len(TmpList)==1:
                        self.GauIO.OptionList.append(\
                            DFTD.GrimDict[key][1])
                    elif len(TmpList)==2:
                        self.GauIO.OptionList.append(\
                            '/'.join([DFTD.GrimDict[key][1],\
                            TmpList[1]]))
                    else:
                        print_Error(self.IOut,
                            'Error happens in DFT+D method '+\
                            'determination \"DFTD.__init__\"')
                    self.GauIO.OptionList.remove(option)
                    break
        if not self.TurnOn:                                          # Filter pure disp. calc.
            for option in self.GauIO.OptionList:
                for key in sorted(DFTD.DispDict.keys()):
                    TmpList = option.strip().split('/')
                    if TmpList[0].lower()==key:
                        self.TurnOn = True
                        self.Method = key
                        self.SixPara    = DFTD.DispDict[key][0]
                        if len(TmpList)==1:
                            self.GauIO.OptionList.append(\
                                DFTD.DispDict[key][1])
                        elif len(TmpList)==2:
                            self.GauIO.OptionList.append(\
                                '/'.join([DFTD.DispDict[key][1],\
                                TmpList[1]]))
                        else:
                            print_Error(self.IOut,
                                'Error happens in Disp. method '+\
                                'determination \"DFTD.__init__\"')
                        self.GauIO.OptionList.remove(option)

        self.OptClass.OptionList    = self.GauIO.OptionList[:]       # Sync OptionList between 
                                                                     #  "OptClass" and "GauIO"
        if self.TurnOn:
            if (self.Method == 'disp_g') or\
            (self.Method == 'dispersion_g'):
                self.PureDisp   = True
                self.DispClass  =\
                    DispGrim(self.IOut, GauIO.CList, GauIO.IAn, 0,\
                    self.IPrint,\
                    c6para, c12para, r0para, dpara)
                if self.IPrint>=1:
                    print_String(self.IOut, 'Disp_G is required',1)
                return
            if (self.Method == 'disp_6') or\
            (self.Method == 'dispersion_6'):
                self.PureDisp   = True
                self.DispClass  =\
                    DispGrim(self.IOut, GauIO.CList, GauIO.IAn, 1,\
                    self.IPrint,\
                    c6para, c12para, r0para, dpara)
                if self.IPrint>=1:
                    print_String(self.IOut, 'Disp_6 is required',1)
                return
            if (self.Method == 'disp_12') or\
            (self.Method == 'dispersion_12'):
                self.PureDisp   = True
                self.DispClass  =\
                    DispGrim(self.IOut, GauIO.CList, GauIO.IAn, 2,\
                    self.IPrint,\
                    c6para, c12para, r0para, dpara)
                if self.IPrint>=1:
                    print_String(self.IOut, 'Disp_12 is required',1)
                return
            if (self.Method == 'disp') or\
            (self.Method == 'dispersion'):
                self.PureDisp   = True
                self.DispClass       =\
                    DispGrim(self.IOut, GauIO.CList, GauIO.IAn, 3,\
                    self.IPrint,\
                    c6para, c12para, r0para, dpara)
                if self.IPrint>=1:
                    print_String(self.IOut,'Disp. is required',1)
                return
            if (self.Method == 'disp_12s') or\
            (self.Method == 'dispersion_12s'):
                self.PureDisp   = True
                self.DispClass       =\
                    DispGrim(self.IOut, GauIO.CList, GauIO.IAn, 4,\
                    self.IPrint,\
                    c6para, c12para, r0para, dpara)
                if self.IPrint>=1:
                    print_String(self.IOut,'Disp_12s is required',1)
                return

            for option in self.OptClass.OptionList:
                TmpList=option.strip().split('/')
                if TmpList[0].lower()==self.Method:
                    if len(TmpList)==1:
                        self.OptClass.OptionList.append(\
                            DFTD.GrimDict[self.Method][1])
                    elif len(TmpList)==2:
                        self.OptClass.OptionList.append(\
                            DFTD.GrimDict[self.Method][1])
                        self.OptClass.OptionList.append(\
                            TmpList[1])
                    self.OptClass.OptionList.remove(option)
                    break
            self.DispClass       =\
                DispGrim(self.IOut, GauIO.CList, GauIO.IAn, 0,\
                self.IPrint)
            if self.IPrint>=1:
                print_String(self.IOut,
                    '%s is employed with s_6 = %3.2f'
                    % (self.Method.upper(),self.SixPara),2)
        else:
            self.DispClass       =\
                DispGrim(self.IOut, GauIO.CList, GauIO.IAn, 0,\
                self.IPrint)
            if self.IPrint>=2:
                print_String(self.IOut,
                    'None DFT+D scheme is required',1)
        return
    def __del__(self):

        return
    def get_EngyReal(self,ICtrl=0):
        '''\
        Get DFT+D or Dispersion energy\n\
        NOTE :: ICtrl   = 0 : default, the same as 1\n\
                        = 1 : to run_GauJob() before QM energy collecting\n\
                          2 : bypass run_GauJob(), to get QM energy from given Chkfile\n\
        '''
        from my_io      import my_plus
        if self.PureDisp:
            self.EngyReal   = self.DispClass.get_EngyReal()
        elif ICtrl==0 or ICtrl==1:                                   # run_GauJob() for QM results
            self.EngyReal   = self.DispClass.get_EngyReal() *\
                self.SixPara
            self.GauIO.form_Inp()
            self.GauIO.run_GauJob()
            Result  = ChkHandle(self.IOut,self.GauIO,self.IPrint)
            self.EngyReal   = my_plus(self.EngyReal,
                Result.collect_EngyReal())
            del Result
        elif ICtrl==2:                                               # bypass run_GauJob()
            self.EngyReal   = self.DispClass.get_EngyReal() *\
                self.SixPara
            Result  = ChkHandle(self.IOut,self.GauIO,self.IPrint)
            self.EngyReal   = my_plus(self.EngyReal,
                Result.collect_EngyReal())
            del Result
        return self.EngyReal
    def get_ForcList(self,ICtrl=0):
        '''\
        Get DFT+D or Dispersion force\n\
        NOTE :: ICtrl   = 0 : default, the same as 1\n\
                        = 1 : to run_GauJob() before QM force collecting\n\
                          2 : bypass run_GauJob(), to get QM force from given Chkfile\n\
        '''
        from my_io      import my_plus
        if self.PureDisp:
            self.ForcList   =\
                [x for x in self.DispClass.get_ForcList()]
        elif ICtrl==0 or ICtrl==1:
            self.ForcList   =\
                [x *self.SixPara\
                for x in self.DispClass.get_ForcList()]
            self.GauIO.form_Inp()
            self.GauIO.run_GauJob()
            Result  = ChkHandle(self.IOut,self.GauIO,self.IPrint)
            for i in range(len(self.ForcList)):
                self.ForcList[i] = my_plus(self.ForcList[i],
                    Result[i])
            del Result
        elif ICtrl==2:
            self.ForcList   =\
                [x *self.SixPara\
                for x in self.DispClass.get_ForcList()]
            Result  = ChkHandle(self.IOut,self.GauIO,self.IPrint)
            for i in range(len(self.ForcList)):
                self.ForcList[i] = my_plus(self.ForcList[i],
                    Result[i])
            del Result
        return self.ForcList
            
